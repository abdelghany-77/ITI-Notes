<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures Study Guide</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.svg">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Table of Contents Styles (Enhanced) */
        .toc-container {
            position: fixed;
            top: 20px;
            left: -320px;
            width: 300px;
            height: calc(100vh - 40px);
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 
              0 20px 50px rgba(0, 0, 0, 0.3),
              0 10px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            overflow: hidden;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .toc-container.active {
            left: 20px;
            transform: translateY(0);
        }

        /* Add backdrop overlay */
        .toc-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .toc-backdrop.active {
            opacity: 1;
            visibility: visible;
        }
        
        .toc-header {
            padding: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px 20px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .toc-header h3 {
            margin: 0;
            font-size: 1.3em;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        .toc-list {
            padding: 20px;
            height: calc(100% - 80px);
            overflow-y: auto;
        }
        
        .toc-list ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .toc-list li {
            margin: 8px 0;
        }
        
        .toc-list a {
            display: block;
            padding: 8px 12px;
            color: #2c3e50;
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }
        
        .toc-list a:hover {
            background: #3498db;
            color: white;
            transform: translateX(5px);
        }
        
        .toc-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 18px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1001;
            font-size: 20px;
            font-weight: bold;
            box-shadow: 
              0 8px 25px rgba(102, 126, 234, 0.4),
              0 4px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .toc-toggle:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 
              0 12px 35px rgba(118, 75, 162, 0.5),
              0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .toc-toggle:active {
            transform: scale(1.05) rotate(90deg);
        }
        
        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1000;
            font-size: 18px;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }
        
        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .back-to-top:hover {
            background: #c0392b;
            transform: scale(1.1);
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .nav-links {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .nav-links a {
            display: inline-block;
            padding: 12px 25px;
            background: rgba(255, 255, 255, 0.9);
            color: #2c3e50;
            text-decoration: none;
            border-radius: 25px;
            margin: 0 10px;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .nav-links a:hover {
            background: #3498db;
            color: white;
            transform: translateY(-2px);
        }
        
        .topic-section {
            background: rgba(255, 255, 255, 0.95);
            margin: 20px 0;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }
        
        .topic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 2px solid #ecf0f1;
            margin-bottom: 20px;
        }
        
        .topic-header h2 {
            color: #2c3e50;
            font-size: 1.8em;
        }
        
        .difficulty {
            padding: 8px 15px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .beginner { background: #27ae60; }
        .intermediate { background: #f39c12; }
        .advanced { background: #e74c3c; }
        
        .topic-content {
            display: block;
        }
        
        .topic-content.hidden {
            display: none;
        }
        
        .subtopic {
            background: #f8f9fa;
            margin: 15px 0;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }
        
        .subtopic h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .video-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .video-section video {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.1);
            background: #000;
            object-fit: contain;
        }
        
        /* Style for video error messages */
        .video-error {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            padding: 40px 20px;
            text-align: center;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .video-error h4 {
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .video-error ul {
            text-align: left;
            display: inline-block;
            max-width: 600px;
        }
        
        .video-error li {
            padding: 5px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .video-placeholder {
            background: #bdc3c7;
            height: 200px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2c3e50;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .video-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .video-link {
            padding: 8px 15px;
            background: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 0.9em;
            transition: background 0.3s ease;
        }
        
        .video-link:hover {
            background: #2980b9;
        }
        
        /* Enhanced Code Examples with VS Code Dark Theme */
        .code-example,
        pre {
            background: linear-gradient(145deg, #1e1e1e 0%, #252526 100%);
            color: #d4d4d4;
            padding: 25px;
            border-radius: 12px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: "Fira Code", "Consolas", "Monaco", "Courier New", monospace;
            font-size: 14px;
            line-height: 1.6;
            border: 1px solid #3c3c3c;
            position: relative;
            box-shadow: 
              0 8px 25px rgba(0, 0, 0, 0.4),
              inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }

        .code-example::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #007acc, #00d4ff);
            border-radius: 12px 12px 0 0;
        }

        .code-language {
            position: absolute;
            top: 10px;
            right: 15px;
            background: rgba(0, 122, 204, 0.8);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .code-example pre {
            background: none;
            margin: 0;
            padding: 20px 0 0 0;
            border: none;
            box-shadow: none;
        }

        .code-example code {
            background: none;
            color: inherit;
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            display: block;
            margin-top: 25px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Syntax Highlighting - Enhanced Colors */
        .code-example .keyword {
            color: #569cd6;
            font-weight: 600;
        }

        .code-example .string {
            color: #ce9178;
        }

        .code-example .comment {
            color: #6a9955;
            font-style: italic;
            opacity: 0.8;
        }

        .code-example .number {
            color: #b5cea8;
        }

        .code-example .function {
            color: #dcdcaa;
            font-weight: 500;
        }

        .code-example .classname {
            color: #4ec9b0;
            font-weight: 500;
        }

        .code-example .type {
            color: #4ec9b0;
        }

        .code-example .operator {
            color: #d4d4d4;
        }

        .code-example .variable {
            color: #9cdcfe;
        }

        .code-example .property {
            color: #9cdcfe;
        }

        .code-example .constant {
            color: #4fc1ff;
            font-weight: 500;
        }

        .code-example .punctuation {
            color: #d4d4d4;
        }

        .code-example .bracket {
            color: #ffd700;
            font-weight: bold;
        }

        /* Code scrollbar styling */
        .code-example::-webkit-scrollbar {
            height: 8px;
        }

        .code-example::-webkit-scrollbar-track {
            background: #2d2d30;
            border-radius: 4px;
        }

        .code-example::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 4px;
        }

        .code-example::-webkit-scrollbar-thumb:hover {
            background: #4f4f4f;
        }

        /* Add subtle selection highlighting */
        .code-example::selection {
            background: rgba(52, 152, 219, 0.3);
        }

        .code-example::-moz-selection {
            background: rgba(52, 152, 219, 0.3);
        }

        /* Inline code styling */
        code {
            background: linear-gradient(135deg, #2d2d30 0%, #1e1e1e 100%);
            color: #ce9178;
            padding: 3px 8px;
            border-radius: 6px;
            font-family: "Fira Code", "Consolas", "Monaco", "Courier New", monospace;
            font-size: 0.85em;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .code-example .punctuation {
            color: #d4d4d4;
        }
        
        .code-example .bracket {
            color: #ffd700;
        }

        /* Highlight Boxes */
        .highlight-box {
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(116, 185, 255, 0.3);
        }

        .highlight-box h4 {
            color: white;
            margin-bottom: 15px;
        }

        /* Content section styling */
        .content-section {
            background: rgba(255, 255, 255, 0.95);
            margin: 20px 0;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .content-section h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 25px;
            font-size: 2.2em;
        }

        .content-section h2 {
            color: #34495e;
            margin: 30px 0 20px 0;
            font-size: 1.8em;
            border-left: 4px solid #e74c3c;
            padding-left: 15px;
        }

        .content-section h3 {
            color: #2c3e50;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
        }

        .content-section h4 {
            color: #34495e;
            margin: 20px 0 10px 0;
            font-size: 1.2em;
        }

        .content-section p {
            margin-bottom: 15px;
            line-height: 1.7;
        }

        .content-section ul, .content-section ol {
            margin: 15px 0;
            padding-left: 25px;
        }

        .content-section li {
            margin-bottom: 8px;
        }
        
        .implementation-list {
            list-style: none;
            padding: 0;
        }
        
        .implementation-list li {
            background: #f8f9fa;
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #27ae60;
        }
        
        .toggle-btn {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #3498db;
            transition: transform 0.3s ease;
        }
        
        .toggle-btn.rotated {
            transform: rotate(180deg);
        }
        
        .practice-section {
            background: #fff3cd;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #ffc107;
            margin-top: 20px;
        }
        
        .practice-section h4 {
            color: #856404;
            margin-bottom: 15px;
        }
        
        .practice-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .practice-link {
            padding: 10px 15px;
            background: #ffc107;
            color: #856404;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .practice-link:hover {
            background: #e0a800;
            color: #fff;
        }
        /* ------------------ Custom Video Player Styles ------------------ */
        .player {
            position: relative;
            max-width: 100%;
            margin: 20px 0;
            border-radius: 12px;
            overflow: visible;
        }

        .player video {
            width: 100%;
            height: 500px;
            display: block;
            border-radius: 12px;
            background: #000;
            outline: none;
        }

        .player .big-play {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 72px;
            height: 72px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.55);
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(0,0,0,0.45);
            transition: opacity 180ms ease, transform 180ms ease;
            opacity: 0;
            z-index: 6;
        }

        .player.paused .big-play {
            opacity: 1;
        }

        .player .controls {
            position: absolute;
            left: 12px;
            right: 12px;
            bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.5));
            border-radius: 12px;
            z-index: 8;
            backdrop-filter: blur(6px);
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
        }

        .player .control-btn {
            background: rgba(255,255,255,0.05);
            border: 0;
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            transition: transform 120ms ease, background 120ms ease;
        }

        .player .control-btn:hover { background: rgba(255,255,255,0.12); transform: translateY(-2px); }

        .player .progress {
            position: relative;
            height: 6px; /* thinner track */
            background: rgba(255,255,255,0.08);
            border-radius: 999px;
            overflow: visible;
            cursor: pointer;
            margin: 0 6px;
        }

        .player .progress .buffer {
            position: absolute; left: 0; top: 0; bottom: 0; width: 0;
            background: rgba(255,255,255,0.12);
            border-radius: 999px;
        }

        .player .progress .bar {
            position: absolute; left: 0; top: 0; bottom: 0; width: 0;
            background: linear-gradient(90deg,#6dd3ff,#7b61ff);
            border-radius: 999px;
            box-shadow: 0 2px 8px rgba(123,97,255,0.25) inset;
        }

        .player .progress .knob {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
            transition: transform 120ms ease;
        }

        .player .time {
            color: #fff;
            font-size: 13px;
            min-width: 80px;
            text-align: center;
        }

        .player input[type="range"].volume {
            width: 100px;
            accent-color: #7b61ff;
        }

        .player select.playback-rate {
            background: linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.6));
            color: #fff;
            border: 1px solid rgba(255,255,255,0.08);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            -webkit-appearance: none;
            appearance: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        .player select.playback-rate option {
            background: #111;
            color: #fff;
        }

        .player .download-link {
            text-decoration: none;
            color: #fff;
            background: rgba(255,255,255,0.06);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 13px;
        }

        /* make controls responsive */
        @media (max-width: 640px) {
            .player .controls { gap: 6px; padding: 6px; }
            .player input[type="range"].volume { width: 70px; }
            .player .time { min-width: 64px; font-size: 12px; }
            .player .progress .knob { width: 12px; height: 12px; }
        }
        /* Fullscreen styles */
        .player:fullscreen, .player:-webkit-full-screen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 99999 !important;
            border-radius: 0 !important;
            background: #000;
        }

        .player:fullscreen video, .player:-webkit-full-screen video {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain !important; /* use 'cover' if you prefer filling/cropping */
        }

        .player:fullscreen .controls, .player:-webkit-full-screen .controls {
            left: 20px !important;
            right: 20px !important;
            bottom: 20px !important;
        }
    </style>
</head>
<body>
    <!-- Table of Contents Toggle Button -->
    <button class="toc-toggle" onclick="toggleTOC()">☰</button>
    
    <!-- Table of Contents -->
    <div class="toc-container" id="tocContainer">
        <div class="toc-header">
            <h3>📋 Table of Contents</h3>
        </div>
        <div class="toc-list">
            <ul>
                <li><a href="#introduction">🎯 Introduction to Data Structures</a></li>
                <li><a href="#stacks">📚 Stacks</a></li>
                <li><a href="#queues">🚶 Queues</a></li>
                <li><a href="#array-lists">📋 Array-Based Lists</a></li>
                <li><a href="#linked-lists">🔗 Linked Lists</a></li>
                <li><a href="#trees">🌳 Trees</a></li>
                <li><a href="#huffman">📊 Huffman Coding</a></li>
                <li><a href="#sorting">🔄 Sorting Algorithms</a></li>
                <li><a href="#searching">🔍 Searching Algorithms</a></li>
                <li><a href="#hash-tables">🗂️ Hash Tables</a></li>
                <li><a href="#graphs">🕸️ Graphs</a></li>
            </ul>
        </div>
    </div>
    
    <!-- TOC Backdrop -->
    <div class="toc-backdrop" id="tocBackdrop"></div>
    
    <!-- Back to Top Button -->
    <button class="back-to-top" id="backToTop" onclick="scrollToTop()">↑</button>

    <div class="container">
        <div class="header">
            <h1>📊 Data Structures Study Guide</h1>
            <p>Master the fundamental building blocks of programming - from basic to advanced</p>
        </div>
        
        <div class="nav-links">
            <a href="../index.html">🏠 Home</a>
        </div>

        <!-- Introduction -->
        <div class="content-section" id="introduction">
            <h1>🎯 Introduction to Data Structures</h1>
            <p>
                Data structures are specialized formats for organizing, storing, and managing data in computer programs. 
                They provide efficient ways to access and manipulate data, forming the backbone of all software applications.
            </p>

            <div class="highlight-box">
                <h4>🔍 What are Data Structures?</h4>
                <p>Data structures are ways of organizing and storing data so that they can be accessed and worked with efficiently. They define the relationship between data elements and the operations that can be performed on them.</p>
            </div>

            <h2>📊 Types of Data Structures</h2>
            
            <h3>1. Linear Data Structures</h3>
            <p>Elements are arranged in a sequential order, where each element has a unique predecessor and successor (except the first and last).</p>
            
            <div class="code-example">
                <div class="code-language">Examples</div>
                <pre><code><span class="comment">// Linear Data Structures</span>
<span class="keyword">1. Array:</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]
<span class="keyword">2. Linked List:</span> <span class="number">10</span> -> <span class="number">20</span> -> <span class="number">30</span> -> <span class="keyword">null</span>
<span class="keyword">3. Stack:</span> [<span class="number">40</span>] <- top
           [<span class="number">30</span>]
           [<span class="number">20</span>]
           [<span class="number">10</span>] <- bottom
<span class="keyword">4. Queue:</span> <span class="number">10</span> -> <span class="number">20</span> -> <span class="number">30</span> -> <span class="number">40</span>
           front              rear</code></pre>
            </div>

            <h3>2. Non-Linear Data Structures</h3>
            <p>Elements are arranged in hierarchical or network relationships, where each element can have multiple predecessors and successors.</p>
            
            <div class="code-example">
                <div class="code-language">Examples</div>
                <pre><code><span class="comment">// Non-Linear Data Structures</span>
<span class="keyword">1. Tree:</span>        <span class="number">50</span>
              /   \
            <span class="number">30</span>     <span class="number">70</span>
           / \   / \
         <span class="number">20</span> <span class="number">40</span> <span class="number">60</span> <span class="number">80</span>

<span class="keyword">2. Graph:</span> <span class="number">A</span> --- <span class="number">B</span>
           |  \ / |
           |   X  |
           |  / \ |
           <span class="number">C</span> --- <span class="number">D</span></code></pre>
            </div>

            <h2>⚡ Why Data Structures Matter</h2>
            <ul>
                <li><strong>Efficiency:</strong> Enable faster data access and manipulation</li>
                <li><strong>Memory Management:</strong> Optimize memory usage and allocation</li>
                <li><strong>Algorithm Design:</strong> Foundation for efficient algorithms</li>
                <li><strong>Problem Solving:</strong> Different structures suit different problems</li>
                <li><strong>Performance:</strong> Direct impact on application speed and responsiveness</li>
            </ul>

            <h2>🔢 Complexity Analysis Fundamentals</h2>
            <p>
                Understanding how to measure and analyze the efficiency of data structures and algorithms 
                is crucial for making informed decisions in software development.
            </p>

            <h3>Time Complexity (Big O Notation)</h3>
            <div class="highlight-box">
                <h4>📈 Common Time Complexities</h4>
                <ul>
                    <li><strong>O(1)</strong> - Constant: Same time regardless of input size</li>
                    <li><strong>O(log n)</strong> - Logarithmic: Divides problem in half each time</li>
                    <li><strong>O(n)</strong> - Linear: Time grows proportionally with input</li>
                    <li><strong>O(n log n)</strong> - Linearithmic: Common in efficient sorting</li>
                    <li><strong>O(n²)</strong> - Quadratic: Nested loops over input</li>
                    <li><strong>O(2ⁿ)</strong> - Exponential: Extremely inefficient for large inputs</li>
                </ul>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Time Complexity Examples</span>

<span class="comment">// O(1) - Constant Time</span>
<span class="keyword">public</span> <span class="type">int</span> <span class="function">getFirstElement</span>(<span class="type">int</span>[] arr) {
    <span class="keyword">return</span> arr[<span class="number">0</span>]; <span class="comment">// Always same time</span>
}

<span class="comment">// O(n) - Linear Time</span>
<span class="keyword">public</span> <span class="type">int</span> <span class="function">findMax</span>(<span class="type">int</span>[] arr) {
    <span class="type">int</span> max = arr[<span class="number">0</span>];
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i < arr.length; i++) {
        <span class="keyword">if</span>(arr[i] > max) max = arr[i];
    }
    <span class="keyword">return</span> max; <span class="comment">// Time grows with array size</span>
}

<span class="comment">// O(n²) - Quadratic Time</span>
<span class="keyword">public</span> <span class="type">void</span> <span class="function">bubbleSort</span>(<span class="type">int</span>[] arr) {
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i < arr.length; i++) {
        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j < arr.length<span class="operator">-</span><span class="number">1</span>; j++) {
            <span class="keyword">if</span>(arr[j] > arr[j<span class="operator">+</span><span class="number">1</span>]) {
                <span class="comment">// Swap elements</span>
                <span class="type">int</span> temp = arr[j];
                arr[j] = arr[j<span class="operator">+</span><span class="number">1</span>];
                arr[j<span class="operator">+</span><span class="number">1</span>] = temp;
            }
        }
    }
}

<span class="comment">// O(log n) - Logarithmic Time</span>
<span class="keyword">public</span> <span class="type">int</span> <span class="function">binarySearch</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target) {
    <span class="type">int</span> left = <span class="number">0</span>, right = arr.length <span class="operator">-</span> <span class="number">1</span>;
    <span class="keyword">while</span>(left <= right) {
        <span class="type">int</span> mid = left <span class="operator">+</span> (right <span class="operator">-</span> left) <span class="operator">/</span> <span class="number">2</span>;
        <span class="keyword">if</span>(arr[mid] == target) <span class="keyword">return</span> mid;
        <span class="keyword">else if</span>(arr[mid] < target) left = mid <span class="operator">+</span> <span class="number">1</span>;
        <span class="keyword">else</span> right = mid <span class="operator">-</span> <span class="number">1</span>;
    }
    <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>; <span class="comment">// Divides search space in half each time</span>
}</code></pre>
            </div>

            <h3>Space Complexity</h3>
            <p>Measures the amount of memory space an algorithm uses relative to input size.</p>
            
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Space Complexity Examples</span>

<span class="comment">// O(1) - Constant Space</span>
<span class="keyword">public</span> <span class="type">void</span> <span class="function">swap</span>(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) {
    <span class="type">int</span> temp = arr[i]; <span class="comment">// Only uses few variables</span>
    arr[i] = arr[j];
    arr[j] = temp;
}

<span class="comment">// O(n) - Linear Space</span>
<span class="keyword">public</span> <span class="type">int</span>[] <span class="function">createCopy</span>(<span class="type">int</span>[] arr) {
    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="type">int</span>[arr.length]; <span class="comment">// Creates array of same size</span>
    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i < arr.length; i++) {
        copy[i] = arr[i];
    }
    <span class="keyword">return</span> copy;
}</code></pre>
            </div>

            <div class="highlight-box">
                <h4>🎯 Choosing the Right Data Structure</h4>
                <ul>
                    <li><strong>Arrays:</strong> Fast random access, fixed size</li>
                    <li><strong>Linked Lists:</strong> Dynamic size, efficient insertion/deletion</li>
                    <li><strong>Stacks:</strong> LIFO operations (undo, function calls)</li>
                    <li><strong>Queues:</strong> FIFO operations (task scheduling, printing)</li>
                    <li><strong>Trees:</strong> Hierarchical data, searching, sorting</li>
                    <li><strong>Hash Tables:</strong> Fast lookups, key-value pairs</li>
                    <li><strong>Graphs:</strong> Network relationships, pathfinding</li>
                </ul>
            </div>
        </div>
                // swap
            }
        }
    }
}</div>
                </div>
                
                <div class="practice-section">
                    <h4>🏋️ Key Concepts</h4>
                    <div class="practice-links">
                        <a href="#" class="practice-link">Big O Notation</a>
                        <a href="#" class="practice-link">Time Complexity</a>
                        <a href="#" class="practice-link">Space Complexity</a>
                        <a href="#" class="practice-link">Algorithm Analysis</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stacks -->
        <div class="content-section" id="stacks">
            <h1>📚 Stacks</h1>
            <p>
                A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. 
                Elements are added and removed from the same end, called the "top" of the stack.
            </p>

            <div class="highlight-box">
                <h4>🔄 LIFO Principle</h4>
                <p>The last element added to the stack is the first one to be removed, just like a stack of plates where you can only take the top plate.</p>
            </div>

            <h2>⚡ Core Stack Operations</h2>
            <div class="code-example">
                <div class="code-language">Operations</div>
                <pre><code><span class="comment">// Stack Basic Operations</span>
<span class="keyword">1. Push:</span> Add element to top
<span class="keyword">2. Pop:</span> Remove element from top  
<span class="keyword">3. Peek/Top:</span> View top element without removing
<span class="keyword">4. isEmpty:</span> Check if stack is empty
<span class="keyword">5. isFull:</span> Check if stack is full (array implementation)
<span class="keyword">6. Size:</span> Get number of elements

<span class="comment">// Visual Representation</span>
Push(<span class="number">30</span>)  →  [<span class="number">30</span>] ← top
Push(<span class="number">20</span>)  →  [<span class="number">20</span>] ← top
             [<span class="number">30</span>]
Push(<span class="number">10</span>)  →  [<span class="number">10</span>] ← top
             [<span class="number">20</span>]
             [<span class="number">30</span>]
Pop()    →  [<span class="number">20</span>] ← top (removed <span class="number">10</span>)
             [<span class="number">30</span>]</code></pre>
            </div>

            <h2>🛠️ Implementation Methods</h2>

            <h3>1. Array-based Stack Implementation</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">class</span> <span class="classname">ArrayStack</span> {
    <span class="keyword">private</span> <span class="type">int</span>[] arr;
    <span class="keyword">private</span> <span class="type">int</span> top;
    <span class="keyword">private</span> <span class="type">int</span> capacity;
    
    <span class="comment">// Constructor</span>
    <span class="keyword">public</span> <span class="function">ArrayStack</span>(<span class="type">int</span> size) {
        arr = <span class="keyword">new</span> <span class="type">int</span>[size];
        capacity = size;
        top = <span class="operator">-</span><span class="number">1</span>; <span class="comment">// Stack is empty initially</span>
    }
    
    <span class="comment">// Push operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">push</span>(<span class="type">int</span> element) {
        <span class="keyword">if</span> (isFull()) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"Stack Overflow"</span>);
        }
        arr[<span class="operator">++</span>top] = element;
        System.out.println(<span class="string">"Pushed: "</span> <span class="operator">+</span> element);
    }
    
    <span class="comment">// Pop operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">pop</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"Stack Underflow"</span>);
        }
        <span class="type">int</span> element = arr[top<span class="operator">--</span>];
        System.out.println(<span class="string">"Popped: "</span> <span class="operator">+</span> element);
        <span class="keyword">return</span> element;
    }
    
    <span class="comment">// Peek operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">peek</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"Stack is empty"</span>);
        }
        <span class="keyword">return</span> arr[top];
    }
    
    <span class="comment">// Check if stack is empty - O(1)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> top == <span class="operator">-</span><span class="number">1</span>;
    }
    
    <span class="comment">// Check if stack is full - O(1)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isFull</span>() {
        <span class="keyword">return</span> top == capacity <span class="operator">-</span> <span class="number">1</span>;
    }
    
    <span class="comment">// Get stack size - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">size</span>() {
        <span class="keyword">return</span> top <span class="operator">+</span> <span class="number">1</span>;
    }
    
    <span class="comment">// Display stack elements</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">display</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            System.out.println(<span class="string">"Stack is empty"</span>);
            <span class="keyword">return</span>;
        }
        System.out.print(<span class="string">"Stack: "</span>);
        <span class="keyword">for</span> (<span class="type">int</span> i = top; i >= <span class="number">0</span>; i<span class="operator">--</span>) {
            System.out.print(arr[i] <span class="operator">+</span> <span class="string">" "</span>);
        }
        System.out.println();
    }
}</code></pre>
            </div>

            <h3>2. Linked List-based Stack Implementation</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">class</span> <span class="classname">LinkedListStack</span> {
    <span class="keyword">private</span> <span class="classname">Node</span> top;
    
    <span class="comment">// Node class for linked list</span>
    <span class="keyword">private</span> <span class="keyword">class</span> <span class="classname">Node</span> {
        <span class="type">int</span> data;
        <span class="classname">Node</span> next;
        
        <span class="function">Node</span>(<span class="type">int</span> data) {
            <span class="keyword">this</span>.data = data;
            <span class="keyword">this</span>.next = <span class="keyword">null</span>;
        }
    }
    
    <span class="comment">// Push operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">push</span>(<span class="type">int</span> element) {
        <span class="classname">Node</span> newNode = <span class="keyword">new</span> <span class="classname">Node</span>(element);
        newNode.next = top;
        top = newNode;
        System.out.println(<span class="string">"Pushed: "</span> <span class="operator">+</span> element);
    }
    
    <span class="comment">// Pop operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">pop</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"Stack Underflow"</span>);
        }
        <span class="type">int</span> element = top.data;
        top = top.next;
        System.out.println(<span class="string">"Popped: "</span> <span class="operator">+</span> element);
        <span class="keyword">return</span> element;
    }
    
    <span class="comment">// Peek operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">peek</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"Stack is empty"</span>);
        }
        <span class="keyword">return</span> top.data;
    }
    
    <span class="comment">// Check if stack is empty - O(1)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> top == <span class="keyword">null</span>;
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>📋 Common Use Cases</h4>
                <ul>
                    <li><strong>Function Calls:</strong> Managing function call stack and local variables</li>
                    <li><strong>Undo Operations:</strong> Text editors, image editing software</li>
                    <li><strong>Expression Evaluation:</strong> Converting infix to postfix, evaluating expressions</li>
                    <li><strong>Browser History:</strong> Back button functionality</li>
                    <li><strong>Syntax Parsing:</strong> Checking balanced parentheses, brackets</li>
                    <li><strong>Recursion:</strong> Implementing recursive algorithms iteratively</li>
                </ul>
            </div>

            <h3>Example: Balanced Parentheses Checker</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">ParenthesesChecker</span> {
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="function">isBalanced</span>(<span class="classname">String</span> expression) {
        <span class="classname">Stack</span>&lt;<span class="classname">Character</span>&gt; stack = <span class="keyword">new</span> <span class="classname">Stack</span>&lt;&gt;();
        
        <span class="keyword">for</span> (<span class="type">char</span> ch : expression.toCharArray()) {
            <span class="comment">// Push opening brackets</span>
            <span class="keyword">if</span> (ch == <span class="string">'('</span> || ch == <span class="string">'{'</span> || ch == <span class="string">'['</span>) {
                stack.push(ch);
            }
            <span class="comment">// Check closing brackets</span>
            <span class="keyword">else if</span> (ch == <span class="string">')'</span> || ch == <span class="string">'}'</span> || ch == <span class="string">']'</span>) {
                <span class="keyword">if</span> (stack.isEmpty()) {
                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// No matching opening bracket</span>
                }
                
                <span class="type">char</span> opening = stack.pop();
                <span class="keyword">if</span> (!isMatchingPair(opening, ch)) {
                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Mismatched brackets</span>
                }
            }
        }
        
        <span class="keyword">return</span> stack.isEmpty(); <span class="comment">// All brackets should be matched</span>
    }
    
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="function">isMatchingPair</span>(<span class="type">char</span> opening, <span class="type">char</span> closing) {
        <span class="keyword">return</span> (opening == <span class="string">'('</span> && closing == <span class="string">')'</span>) ||
               (opening == <span class="string">'{'</span> && closing == <span class="string">'}'</span>) ||
               (opening == <span class="string">'['</span> && closing == <span class="string">']'</span>);
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">void</span> <span class="function">main</span>(<span class="classname">String</span>[] args) {
        <span class="classname">String</span>[] expressions = {
            <span class="string">"()"</span>, <span class="string">"()[]{}"</span>, <span class="string">"([)]"</span>, <span class="string">"((()))"</span>, <span class="string">"())"</span>
        };
        
        <span class="keyword">for</span> (<span class="classname">String</span> expr : expressions) {
            System.out.println(expr <span class="operator">+</span> <span class="string">" is "</span> <span class="operator">+</span> 
                (isBalanced(expr) ? <span class="string">"balanced"</span> : <span class="string">"not balanced"</span>));
        }
    }
}</code></pre>
            </div>

            <h3>Example: Infix to Postfix Conversion</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">InfixToPostfix</span> {
    
    <span class="comment">// Get precedence of operators</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="function">precedence</span>(<span class="type">char</span> operator) {
        <span class="keyword">switch</span> (operator) {
            <span class="keyword">case</span> <span class="string">'+'</span>:
            <span class="keyword">case</span> <span class="string">'-'</span>:
                <span class="keyword">return</span> <span class="number">1</span>;
            <span class="keyword">case</span> <span class="string">'*'</span>:
            <span class="keyword">case</span> <span class="string">'/'</span>:
                <span class="keyword">return</span> <span class="number">2</span>;
            <span class="keyword">case</span> <span class="string">'^'</span>:
                <span class="keyword">return</span> <span class="number">3</span>;
        }
        <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="classname">String</span> <span class="function">infixToPostfix</span>(<span class="classname">String</span> infix) {
        <span class="classname">Stack</span>&lt;<span class="classname">Character</span>&gt; stack = <span class="keyword">new</span> <span class="classname">Stack</span>&lt;&gt;();
        <span class="classname">StringBuilder</span> result = <span class="keyword">new</span> <span class="classname">StringBuilder</span>();
        
        <span class="keyword">for</span> (<span class="type">char</span> c : infix.toCharArray()) {
            <span class="keyword">if</span> (Character.isLetterOrDigit(c)) {
                result.append(c);
            } <span class="keyword">else if</span> (c == <span class="string">'('</span>) {
                stack.push(c);
            } <span class="keyword">else if</span> (c == <span class="string">')'</span>) {
                <span class="keyword">while</span> (!stack.isEmpty() && stack.peek() != <span class="string">'('</span>) {
                    result.append(stack.pop());
                }
                stack.pop(); <span class="comment">// Remove '('</span>
            } <span class="keyword">else</span> { <span class="comment">// Operator</span>
                <span class="keyword">while</span> (!stack.isEmpty() && 
                       precedence(c) <= precedence(stack.peek())) {
                    result.append(stack.pop());
                }
                stack.push(c);
            }
        }
        
        <span class="keyword">while</span> (!stack.isEmpty()) {
            result.append(stack.pop());
        }
        
        <span class="keyword">return</span> result.toString();
    }
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">void</span> <span class="function">main</span>(<span class="classname">String</span>[] args) {
        <span class="classname">String</span> infix = <span class="string">"A+B*C-D/E"</span>;
        System.out.println(<span class="string">"Infix: "</span> <span class="operator">+</span> infix);
        System.out.println(<span class="string">"Postfix: "</span> <span class="operator">+</span> infixToPostfix(infix));
        
        <span class="comment">// Output: ABC*+DE/-</span>
    }
}</code></pre>
            </div>

            <h2>📊 Time and Space Complexity</h2>
            <div class="highlight-box">
                <h4>⚡ Complexity Analysis</h4>
                <ul>
                    <li><strong>Push:</strong> O(1) - Constant time insertion</li>
                    <li><strong>Pop:</strong> O(1) - Constant time removal</li>
                    <li><strong>Peek:</strong> O(1) - Constant time access</li>
                    <li><strong>isEmpty/isFull:</strong> O(1) - Constant time checks</li>
                    <li><strong>Space Complexity:</strong> O(n) - Linear space for n elements</li>
                </ul>
            </div>

            <h2>⚖️ Array vs Linked List Implementation</h2>
            <div class="code-example">
                <div class="code-language">Comparison</div>
                <pre><code><span class="comment">// Array-based Stack</span>
<span class="keyword">Advantages:</span>
  • Fast access (O(1) for all operations)
  • Memory efficient (no extra pointers)
  • Cache friendly (contiguous memory)

<span class="keyword">Disadvantages:</span>
  • Fixed size (may cause overflow)
  • Memory wastage if underutilized

<span class="comment">// Linked List-based Stack</span>
<span class="keyword">Advantages:</span>
  • Dynamic size (no overflow issues)
  • Memory efficient (allocates as needed)
  • No size limitations

<span class="keyword">Disadvantages:</span>
  • Extra memory for pointers
  • Cache misses (non-contiguous memory)
  • Slightly slower due to pointer operations</code></pre>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Valid Parentheses</a>
                    <a href="#" class="practice-link">Min Stack</a>
                    <a href="#" class="practice-link">Evaluate RPN</a>
                    <a href="#" class="practice-link">Daily Temperatures</a>
                    <a href="#" class="practice-link">Next Greater Element</a>
                    <a href="#" class="practice-link">Largest Rectangle in Histogram</a>
                </div>
            </div>
        </div>

        <!-- Queues -->
        <div class="content-section" id="queues">
            <h1>🚶‍♂️ Queues</h1>
            <p>
                A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. 
                Elements are added at the rear (back) and removed from the front, just like people standing in a line.
            </p>

            <div class="highlight-box">
                <h4>🎯 FIFO Principle</h4>
                <p>The first element added to the queue is the first one to be removed, similar to people waiting in line at a bank or store.</p>
            </div>

            <h2>⚡ Core Queue Operations</h2>
            <div class="code-example">
                <div class="code-language">Operations</div>
                <pre><code><span class="comment">// Queue Basic Operations</span>
<span class="keyword">1. Enqueue:</span> Add element to rear
<span class="keyword">2. Dequeue:</span> Remove element from front
<span class="keyword">3. Front/Peek:</span> View front element without removing
<span class="keyword">4. isEmpty:</span> Check if queue is empty
<span class="keyword">5. isFull:</span> Check if queue is full (array implementation)
<span class="keyword">6. Size:</span> Get number of elements

<span class="comment">// Visual Representation</span>
Enqueue(<span class="number">10</span>) →  [<span class="number">10</span>]
                front ↑ ↑ rear

Enqueue(<span class="number">20</span>) →  [<span class="number">10</span>][<span class="number">20</span>]
                front ↑    ↑ rear

Enqueue(<span class="number">30</span>) →  [<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>]
                front ↑         ↑ rear

Dequeue()   →  [<span class="number">20</span>][<span class="number">30</span>] (removed <span class="number">10</span>)
                front ↑    ↑ rear</code></pre>
            </div>

            <h2>🔄 Simple Queue vs Circular Queue</h2>
            <div class="highlight-box">
                <h4>⚠️ Simple Queue Problem</h4>
                <p>In a simple queue implementation, after several enqueue/dequeue operations, the front pointer moves forward but the rear might reach the array end, making the queue "full" even though there are empty slots at the beginning.</p>
            </div>

            <h2>🛠️ Implementation Methods</h2>

            <h3>1. Simple Queue Implementation</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">class</span> <span class="classname">SimpleQueue</span> {
    <span class="keyword">private</span> <span class="type">int</span>[] arr;
    <span class="keyword">private</span> <span class="type">int</span> front, rear, size, capacity;
    
    <span class="comment">// Constructor</span>
    <span class="keyword">public</span> <span class="function">SimpleQueue</span>(<span class="type">int</span> cap) {
        capacity = cap;
        arr = <span class="keyword">new</span> <span class="type">int</span>[capacity];
        front = <span class="number">0</span>;
        rear = <span class="operator">-</span><span class="number">1</span>;
        size = <span class="number">0</span>;
    }
    
    <span class="comment">// Enqueue operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">enqueue</span>(<span class="type">int</span> item) {
        <span class="keyword">if</span> (rear == capacity <span class="operator">-</span> <span class="number">1</span>) {
            System.out.println(<span class="string">"Queue Overflow"</span>);
            <span class="keyword">return</span>;
        }
        arr[<span class="operator">++</span>rear] = item;
        size<span class="operator">++</span>;
        System.out.println(<span class="string">"Enqueued: "</span> <span class="operator">+</span> item);
    }
    
    <span class="comment">// Dequeue operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">dequeue</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            System.out.println(<span class="string">"Queue Underflow"</span>);
            <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
        }
        <span class="type">int</span> item = arr[front<span class="operator">++</span>];
        size<span class="operator">--</span>;
        System.out.println(<span class="string">"Dequeued: "</span> <span class="operator">+</span> item);
        <span class="keyword">return</span> item;
    }
    
    <span class="comment">// Front operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">front</span>() {
        <span class="keyword">return</span> isEmpty() ? <span class="operator">-</span><span class="number">1</span> : arr[front];
    }
    
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> size == <span class="number">0</span>;
    }
    
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">size</span>() {
        <span class="keyword">return</span> size;
    }
}</code></pre>
            </div>

            <h3>2. Circular Queue Implementation (Recommended)</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">class</span> <span class="classname">CircularQueue</span> {
    <span class="keyword">private</span> <span class="type">int</span>[] arr;
    <span class="keyword">private</span> <span class="type">int</span> front, rear, size, capacity;
    
    <span class="comment">// Constructor</span>
    <span class="keyword">public</span> <span class="function">CircularQueue</span>(<span class="type">int</span> cap) {
        capacity = cap;
        arr = <span class="keyword">new</span> <span class="type">int</span>[capacity];
        front = <span class="number">0</span>;
        rear = <span class="operator">-</span><span class="number">1</span>;
        size = <span class="number">0</span>;
    }
    
    <span class="comment">// Enqueue operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">enqueue</span>(<span class="type">int</span> item) {
        <span class="keyword">if</span> (isFull()) {
            System.out.println(<span class="string">"Queue is full"</span>);
            <span class="keyword">return</span>;
        }
        rear = (rear <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> capacity; <span class="comment">// Wrap around</span>
        arr[rear] = item;
        size<span class="operator">++</span>;
        System.out.println(<span class="string">"Enqueued: "</span> <span class="operator">+</span> item);
    }
    
    <span class="comment">// Dequeue operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">dequeue</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            System.out.println(<span class="string">"Queue is empty"</span>);
            <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
        }
        <span class="type">int</span> item = arr[front];
        front = (front <span class="operator">+</span> <span class="number">1</span>) <span class="operator">%</span> capacity; <span class="comment">// Wrap around</span>
        size<span class="operator">--</span>;
        System.out.println(<span class="string">"Dequeued: "</span> <span class="operator">+</span> item);
        <span class="keyword">return</span> item;
    }
    
    <span class="comment">// Front operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">front</span>() {
        <span class="keyword">return</span> isEmpty() ? <span class="operator">-</span><span class="number">1</span> : arr[front];
    }
    
    <span class="comment">// Check operations - O(1)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> size == <span class="number">0</span>;
    }
    
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isFull</span>() {
        <span class="keyword">return</span> size == capacity;
    }
    
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">size</span>() {
        <span class="keyword">return</span> size;
    }
    
    <span class="comment">// Display queue elements</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">display</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            System.out.println(<span class="string">"Queue is empty"</span>);
            <span class="keyword">return</span>;
        }
        System.out.print(<span class="string">"Queue: "</span>);
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i<span class="operator">++</span>) {
            <span class="type">int</span> index = (front <span class="operator">+</span> i) <span class="operator">%</span> capacity;
            System.out.print(arr[index] <span class="operator">+</span> <span class="string">" "</span>);
        }
        System.out.println();
    }
}</code></pre>
            </div>

            <h3>3. Linked List-based Queue Implementation</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">class</span> <span class="classname">LinkedQueue</span> {
    <span class="keyword">private</span> <span class="classname">Node</span> front, rear;
    
    <span class="comment">// Node class for linked list</span>
    <span class="keyword">private</span> <span class="keyword">class</span> <span class="classname">Node</span> {
        <span class="type">int</span> data;
        <span class="classname">Node</span> next;
        
        <span class="function">Node</span>(<span class="type">int</span> data) {
            <span class="keyword">this</span>.data = data;
            <span class="keyword">this</span>.next = <span class="keyword">null</span>;
        }
    }
    
    <span class="comment">// Constructor</span>
    <span class="keyword">public</span> <span class="function">LinkedQueue</span>() {
        front = rear = <span class="keyword">null</span>;
    }
    
    <span class="comment">// Enqueue operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">enqueue</span>(<span class="type">int</span> data) {
        <span class="classname">Node</span> newNode = <span class="keyword">new</span> <span class="classname">Node</span>(data);
        
        <span class="keyword">if</span> (rear == <span class="keyword">null</span>) {
            <span class="comment">// First element</span>
            front = rear = newNode;
        } <span class="keyword">else</span> {
            <span class="comment">// Add to rear</span>
            rear.next = newNode;
            rear = newNode;
        }
        System.out.println(<span class="string">"Enqueued: "</span> <span class="operator">+</span> data);
    }
    
    <span class="comment">// Dequeue operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">dequeue</span>() {
        <span class="keyword">if</span> (isEmpty()) {
            System.out.println(<span class="string">"Queue is empty"</span>);
            <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
        }
        
        <span class="type">int</span> data = front.data;
        front = front.next;
        
        <span class="comment">// If queue becomes empty</span>
        <span class="keyword">if</span> (front == <span class="keyword">null</span>) {
            rear = <span class="keyword">null</span>;
        }
        
        System.out.println(<span class="string">"Dequeued: "</span> <span class="operator">+</span> data);
        <span class="keyword">return</span> data;
    }
    
    <span class="comment">// Front operation - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">front</span>() {
        <span class="keyword">return</span> isEmpty() ? <span class="operator">-</span><span class="number">1</span> : front.data;
    }
    
    <span class="comment">// Check if empty - O(1)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> front == <span class="keyword">null</span>;
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>📋 Common Use Cases</h4>
                <ul>
                    <li><strong>Process Scheduling:</strong> Operating systems use queues for CPU scheduling</li>
                    <li><strong>Breadth-First Search:</strong> Graph and tree traversal algorithms</li>
                    <li><strong>Buffer Management:</strong> Handling requests in web servers, I/O operations</li>
                    <li><strong>Print Queue:</strong> Managing printing jobs in order</li>
                    <li><strong>Task Scheduling:</strong> Background job processing systems</li>
                    <li><strong>Handling Interrupts:</strong> Managing hardware and software interrupts</li>
                </ul>
            </div>

            <h3>Example: Task Scheduler Implementation</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">TaskScheduler</span> {
    <span class="keyword">private</span> <span class="classname">Queue</span>&lt;<span class="classname">Task</span>&gt; taskQueue;
    
    <span class="keyword">public</span> <span class="function">TaskScheduler</span>() {
        taskQueue = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
    }
    
    <span class="comment">// Add task to queue</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">scheduleTask</span>(<span class="classname">Task</span> task) {
        taskQueue.offer(task);
        System.out.println(<span class="string">"Scheduled: "</span> <span class="operator">+</span> task.getName());
    }
    
    <span class="comment">// Execute next task</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">executeNextTask</span>() {
        <span class="keyword">if</span> (taskQueue.isEmpty()) {
            System.out.println(<span class="string">"No tasks to execute"</span>);
            <span class="keyword">return</span>;
        }
        
        <span class="classname">Task</span> currentTask = taskQueue.poll();
        System.out.println(<span class="string">"Executing: "</span> <span class="operator">+</span> currentTask.getName());
        currentTask.execute();
    }
    
    <span class="comment">// Check pending tasks</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">getPendingTasksCount</span>() {
        <span class="keyword">return</span> taskQueue.size();
    }
    
    <span class="comment">// Get next task without removing</span>
    <span class="keyword">public</span> <span class="classname">Task</span> <span class="function">peekNextTask</span>() {
        <span class="keyword">return</span> taskQueue.peek();
    }
}

<span class="keyword">class</span> <span class="classname">Task</span> {
    <span class="keyword">private</span> <span class="classname">String</span> name;
    <span class="keyword">private</span> <span class="classname">Runnable</span> action;
    
    <span class="keyword">public</span> <span class="function">Task</span>(<span class="classname">String</span> name, <span class="classname">Runnable</span> action) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.action = action;
    }
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">execute</span>() {
        action.run();
    }
    
    <span class="keyword">public</span> <span class="classname">String</span> <span class="function">getName</span>() {
        <span class="keyword">return</span> name;
    }
}</code></pre>
            </div>

            <h2>📊 Time and Space Complexity</h2>
            <div class="highlight-box">
                <h4>⚡ Complexity Analysis</h4>
                <ul>
                    <li><strong>Enqueue:</strong> O(1) - Constant time insertion</li>
                    <li><strong>Dequeue:</strong> O(1) - Constant time removal</li>
                    <li><strong>Front/Peek:</strong> O(1) - Constant time access</li>
                    <li><strong>isEmpty/isFull:</strong> O(1) - Constant time checks</li>
                    <li><strong>Space Complexity:</strong> O(n) - Linear space for n elements</li>
                </ul>
            </div>

            <h2>⚖️ Implementation Comparison</h2>
            <div class="code-example">
                <div class="code-language">Comparison</div>
                <pre><code><span class="comment">// Simple Array Queue</span>
<span class="keyword">Advantages:</span>
  • Simple implementation
  • Fast access to elements

<span class="keyword">Disadvantages:</span>
  • Memory wastage after dequeue operations
  • May show "full" when slots are available

<span class="comment">// Circular Array Queue</span>
<span class="keyword">Advantages:</span>
  • Efficient memory utilization
  • No memory wastage
  • Fast operations O(1)

<span class="keyword">Disadvantages:</span>
  • Fixed size limitation
  • Slightly complex implementation

<span class="comment">// Linked List Queue</span>
<span class="keyword">Advantages:</span>
  • Dynamic size (no overflow)
  • Memory efficient (allocates as needed)
  • Simple enqueue/dequeue logic

<span class="keyword">Disadvantages:</span>
  • Extra memory for pointers
  • Cache misses (non-contiguous memory)</code></pre>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Implement Queue using Stacks</a>
                    <a href="#" class="practice-link">Design Circular Queue</a>
                    <a href="#" class="practice-link">Sliding Window Maximum</a>
                    <a href="#" class="practice-link">Generate Binary Numbers</a>
                    <a href="#" class="practice-link">Level Order Traversal</a>
                    <a href="#" class="practice-link">Hot Potato Problem</a>
                </div>
            </div>
        </div>

        <!-- Array-Based List -->
        <div class="topic-section" id="array-lists">
            <div class="topic-header" onclick="toggleContent('array-list')">
                <h2>📋 Array-Based List</h2>
                <div>
                    <span class="difficulty beginner">Beginner</span>
                    <button class="toggle-btn" id="array-list-btn">▼</button>
                </div>
            </div>
            <div class="topic-content" id="array-list-content">
                <div class="subtopic">
                    <h3>#012 Array Based List with Implementation</h3>
                    <p>Dynamic arrays that can grow and shrink, implementing list abstract data type using arrays.</p>
                    
                    <div class="code-example">// Array Based List Implementation
class ArrayList {
    private int[] arr;
    private int size;
    private int capacity;
    
    public ArrayList() {
        capacity = 10;
        arr = new int[capacity];
        size = 0;
    }
    
    public void add(int element) {
        if (size == capacity) {
            resize();
        }
        arr[size++] = element;
    }
    
    public void insert(int index, int element) {
        if (size == capacity) resize();
        
        for (int i = size; i > index; i--) {
            arr[i] = arr[i - 1];
        }
        arr[index] = element;
        size++;
    }
    
    public int remove(int index) {
        if (index < 0 || index >= size) return -1;
        
        int element = arr[index];
        for (int i = index; i < size - 1; i++) {
            arr[i] = arr[i + 1];
        }
        size--;
        return element;
    }
    
    private void resize() {
        capacity *= 2;
        int[] newArr = new int[capacity];
        System.arraycopy(arr, 0, newArr, 0, size);
        arr = newArr;
    }
}</code>
                </div>
                
        <!-- Array-Based List -->
        <div class="content-section" id="array-lists">
            <h1>📋 Array-Based Lists (Dynamic Arrays)</h1>
            <p>
                An Array-Based List (Dynamic Array) is a resizable array implementation that automatically 
                grows and shrinks as elements are added or removed. It provides the benefits of arrays 
                with dynamic size management.
            </p>

            <div class="highlight-box">
                <h4>🔄 Dynamic Resizing</h4>
                <p>Unlike static arrays, dynamic arrays automatically resize when they reach capacity, typically doubling in size to maintain efficient amortized performance.</p>
            </div>

            <h2>⚡ Core Operations</h2>
            <div class="code-example">
                <div class="code-language">Operations</div>
                <pre><code><span class="comment">// Dynamic Array Basic Operations</span>
<span class="keyword">1. Add:</span> Append element to end
<span class="keyword">2. Insert:</span> Insert element at specific index
<span class="keyword">3. Remove:</span> Remove element by index
<span class="keyword">4. Get:</span> Access element by index
<span class="keyword">5. Set:</span> Update element at index
<span class="keyword">6. Size:</span> Get current number of elements
<span class="keyword">7. Contains:</span> Check if element exists

<span class="comment">// Visual Representation</span>
Initial: [<span class="number">10</span>][<span class="number">20</span>][  ][  ] (size=<span class="number">2</span>, capacity=<span class="number">4</span>)
Add(<span class="number">30</span>): [<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>][  ] (size=<span class="number">3</span>, capacity=<span class="number">4</span>)
Add(<span class="number">40</span>): [<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>][<span class="number">40</span>] (size=<span class="number">4</span>, capacity=<span class="number">4</span>)
Add(<span class="number">50</span>): [<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>][<span class="number">40</span>][<span class="number">50</span>][  ][  ][  ] (size=<span class="number">5</span>, capacity=<span class="number">8</span>)</code></pre>
            </div>

            <h2>🛠️ Complete Implementation</h2>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">DynamicArray</span>&lt;T&gt; {
    <span class="keyword">private</span> <span class="classname">Object</span>[] array;
    <span class="keyword">private</span> <span class="type">int</span> size;
    <span class="keyword">private</span> <span class="type">int</span> capacity;
    
    <span class="comment">// Constructor with initial capacity</span>
    <span class="keyword">public</span> <span class="function">DynamicArray</span>(<span class="type">int</span> initialCapacity) {
        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) {
            <span class="keyword">throw new</span> <span class="classname">IllegalArgumentException</span>(<span class="string">"Illegal Capacity: "</span> <span class="operator">+</span> initialCapacity);
        }
        capacity = Math.max(initialCapacity, <span class="number">1</span>);
        array = <span class="keyword">new</span> <span class="classname">Object</span>[capacity];
        size = <span class="number">0</span>;
    }
    
    <span class="comment">// Default constructor</span>
    <span class="keyword">public</span> <span class="function">DynamicArray</span>() {
        <span class="keyword">this</span>(<span class="number">10</span>); <span class="comment">// Default initial capacity</span>
    }
    
    <span class="comment">// Add element to end - O(1) amortized</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">add</span>(T element) {
        <span class="keyword">if</span> (size >= capacity) {
            resize();
        }
        array[size<span class="operator">++</span>] = element;
    }
    
    <span class="comment">// Insert element at specific index - O(n)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insert</span>(<span class="type">int</span> index, T element) {
        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {
            <span class="keyword">throw new</span> <span class="classname">IndexOutOfBoundsException</span>(<span class="string">"Index: "</span> <span class="operator">+</span> index <span class="operator">+</span> <span class="string">", Size: "</span> <span class="operator">+</span> size);
        }
        
        <span class="keyword">if</span> (size >= capacity) {
            resize();
        }
        
        <span class="comment">// Shift elements to the right</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt; index; i<span class="operator">--</span>) {
            array[i] = array[i <span class="operator">-</span> <span class="number">1</span>];
        }
        
        array[index] = element;
        size<span class="operator">++</span>;
    }
    
    <span class="comment">// Remove element by index - O(n)</span>
    <span class="keyword">public</span> T <span class="function">remove</span>(<span class="type">int</span> index) {
        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index >= size) {
            <span class="keyword">throw new</span> <span class="classname">IndexOutOfBoundsException</span>(<span class="string">"Index: "</span> <span class="operator">+</span> index <span class="operator">+</span> <span class="string">", Size: "</span> <span class="operator">+</span> size);
        }
        
        <span class="classname">T</span> removedElement = (T) array[index];
        
        <span class="comment">// Shift elements to the left</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size <span class="operator">-</span> <span class="number">1</span>; i<span class="operator">++</span>) {
            array[i] = array[i <span class="operator">+</span> <span class="number">1</span>];
        }
        
        array[<span class="operator">--</span>size] = <span class="keyword">null</span>; <span class="comment">// Clear reference</span>
        <span class="keyword">return</span> removedElement;
    }
    
    <span class="comment">// Get element by index - O(1)</span>
    <span class="keyword">public</span> T <span class="function">get</span>(<span class="type">int</span> index) {
        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index >= size) {
            <span class="keyword">throw new</span> <span class="classname">IndexOutOfBoundsException</span>(<span class="string">"Index: "</span> <span class="operator">+</span> index <span class="operator">+</span> <span class="string">", Size: "</span> <span class="operator">+</span> size);
        }
        <span class="keyword">return</span> (T) array[index];
    }
    
    <span class="comment">// Resize array (double capacity) - O(n)</span>
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">resize</span>() {
        capacity *= <span class="number">2</span>;
        <span class="classname">Object</span>[] newArray = <span class="keyword">new</span> <span class="classname">Object</span>[capacity];
        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, size);
        array = newArray;
    }
    
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">size</span>() { <span class="keyword">return</span> size; }
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() { <span class="keyword">return</span> size == <span class="number">0</span>; }
}</code></pre>
            </div>

            <h2>📊 Time and Space Complexity</h2>
            <div class="highlight-box">
                <h4>⚡ Complexity Analysis</h4>
                <ul>
                    <li><strong>Add (append):</strong> O(1) amortized - Occasional O(n) for resizing</li>
                    <li><strong>Insert:</strong> O(n) - Need to shift elements</li>
                    <li><strong>Remove:</strong> O(n) - Need to shift elements after removal</li>
                    <li><strong>Get/Set:</strong> O(1) - Direct array access by index</li>
                    <li><strong>Search:</strong> O(n) - Linear search through elements</li>
                    <li><strong>Space Complexity:</strong> O(n) - Linear space for n elements</li>
                </ul>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Implement Dynamic Array</a>
                    <a href="#" class="practice-link">Remove Duplicates</a>
                    <a href="#" class="practice-link">Merge Sorted Arrays</a>
                    <a href="#" class="practice-link">Rotate Array</a>
                    <a href="#" class="practice-link">Two Sum Problem</a>
                </div>
            </div>
        </div>

        <!-- Linked Lists -->
        <div class="content-section" id="linked-lists">
            <h1>🔗 Linked Lists</h1>
            <p>
                A Linked List is a linear data structure where elements are stored in nodes, each containing 
                data and a reference (pointer) to the next node. Unlike arrays, linked list elements are not 
                stored in contiguous memory locations.
            </p>

            <div class="highlight-box">
                <h4>🔗 Node-based Structure</h4>
                <p>Each node contains data and a pointer to the next node, creating a chain-like structure that can grow dynamically during runtime.</p>
            </div>

            <h2>⚡ Core Node Structure</h2>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Basic Node structure</span>
<span class="keyword">class</span> <span class="classname">ListNode</span> {
    <span class="type">int</span> data;           <span class="comment">// Data stored in the node</span>
    <span class="classname">ListNode</span> next;    <span class="comment">// Reference to next node</span>
    
    <span class="comment">// Constructor</span>
    <span class="function">ListNode</span>(<span class="type">int</span> data) {
        <span class="keyword">this</span>.data = data;
        <span class="keyword">this</span>.next = <span class="keyword">null</span>;
    }
}

<span class="comment">// Visual Representation</span>
<span class="keyword">Node 1</span>     <span class="keyword">Node 2</span>     <span class="keyword">Node 3</span>     <span class="keyword">Node 4</span>
[<span class="number">10</span>|•]---->[<span class="number">20</span>|•]---->[<span class="number">30</span>|•]---->[<span class="number">40</span>|null]
 ↑                                        ↑
head                                    tail</code></pre>
            </div>

            <h2>🛠️ Singly Linked List Implementation</h2>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">SinglyLinkedList</span> {
    <span class="keyword">private</span> <span class="classname">ListNode</span> head;
    <span class="keyword">private</span> <span class="type">int</span> size;
    
    <span class="keyword">public</span> <span class="function">SinglyLinkedList</span>() {
        head = <span class="keyword">null</span>;
        size = <span class="number">0</span>;
    }
    
    <span class="comment">// Insert at beginning - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertFirst</span>(<span class="type">int</span> data) {
        <span class="classname">ListNode</span> newNode = <span class="keyword">new</span> <span class="classname">ListNode</span>(data);
        newNode.next = head;
        head = newNode;
        size<span class="operator">++</span>;
        System.out.println(<span class="string">"Inserted at beginning: "</span> <span class="operator">+</span> data);
    }
    
    <span class="comment">// Insert at end - O(n)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertLast</span>(<span class="type">int</span> data) {
        <span class="classname">ListNode</span> newNode = <span class="keyword">new</span> <span class="classname">ListNode</span>(data);
        
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            head = newNode;
        } <span class="keyword">else</span> {
            <span class="classname">ListNode</span> current = head;
            <span class="keyword">while</span> (current.next != <span class="keyword">null</span>) {
                current = current.next;
            }
            current.next = newNode;
        }
        size<span class="operator">++</span>;
        System.out.println(<span class="string">"Inserted at end: "</span> <span class="operator">+</span> data);
    }
    
    <span class="comment">// Insert at specific position - O(n)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertAt</span>(<span class="type">int</span> index, <span class="type">int</span> data) {
        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) {
            <span class="keyword">throw new</span> <span class="classname">IndexOutOfBoundsException</span>(<span class="string">"Index out of bounds"</span>);
        }
        
        <span class="keyword">if</span> (index == <span class="number">0</span>) {
            insertFirst(data);
            <span class="keyword">return</span>;
        }
        
        <span class="classname">ListNode</span> newNode = <span class="keyword">new</span> <span class="classname">ListNode</span>(data);
        <span class="classname">ListNode</span> current = head;
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index <span class="operator">-</span> <span class="number">1</span>; i<span class="operator">++</span>) {
            current = current.next;
        }
        
        newNode.next = current.next;
        current.next = newNode;
        size<span class="operator">++</span>;
        System.out.println(<span class="string">"Inserted at position "</span> <span class="operator">+</span> index <span class="operator">+</span> <span class="string">": "</span> <span class="operator">+</span> data);
    }
    
    <span class="comment">// Remove first node - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">removeFirst</span>() {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"List is empty"</span>);
        }
        
        <span class="type">int</span> data = head.data;
        head = head.next;
        size<span class="operator">--</span>;
        System.out.println(<span class="string">"Removed first: "</span> <span class="operator">+</span> data);
        <span class="keyword">return</span> data;
    }
    
    <span class="comment">// Remove last node - O(n)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">removeLast</span>() {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"List is empty"</span>);
        }
        
        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) {
            <span class="type">int</span> data = head.data;
            head = <span class="keyword">null</span>;
            size<span class="operator">--</span>;
            <span class="keyword">return</span> data;
        }
        
        <span class="classname">ListNode</span> current = head;
        <span class="keyword">while</span> (current.next.next != <span class="keyword">null</span>) {
            current = current.next;
        }
        
        <span class="type">int</span> data = current.next.data;
        current.next = <span class="keyword">null</span>;
        size<span class="operator">--</span>;
        System.out.println(<span class="string">"Removed last: "</span> <span class="operator">+</span> data);
        <span class="keyword">return</span> data;
    }
    
    <span class="comment">// Remove by value - O(n)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">removeByValue</span>(<span class="type">int</span> key) {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        
        <span class="keyword">if</span> (head.data == key) {
            head = head.next;
            size<span class="operator">--</span>;
            System.out.println(<span class="string">"Removed: "</span> <span class="operator">+</span> key);
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        
        <span class="classname">ListNode</span> current = head;
        <span class="keyword">while</span> (current.next != <span class="keyword">null</span> && current.next.data != key) {
            current = current.next;
        }
        
        <span class="keyword">if</span> (current.next != <span class="keyword">null</span>) {
            current.next = current.next.next;
            size<span class="operator">--</span>;
            System.out.println(<span class="string">"Removed: "</span> <span class="operator">+</span> key);
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    
    <span class="comment">// Search for element - O(n)</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">search</span>(<span class="type">int</span> key) {
        <span class="classname">ListNode</span> current = head;
        <span class="keyword">while</span> (current != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (current.data == key) {
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
            current = current.next;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    
    <span class="comment">// Reverse the linked list - O(n)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">reverse</span>() {
        <span class="classname">ListNode</span> prev = <span class="keyword">null</span>;
        <span class="classname">ListNode</span> current = head;
        <span class="classname">ListNode</span> next;
        
        <span class="keyword">while</span> (current != <span class="keyword">null</span>) {
            next = current.next;  <span class="comment">// Store next node</span>
            current.next = prev;  <span class="comment">// Reverse the link</span>
            prev = current;       <span class="comment">// Move prev forward</span>
            current = next;       <span class="comment">// Move current forward</span>
        }
        head = prev;              <span class="comment">// Update head</span>
        System.out.println(<span class="string">"List reversed"</span>);
    }
    
    <span class="comment">// Display the list - O(n)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">display</span>() {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            System.out.println(<span class="string">"List is empty"</span>);
            <span class="keyword">return</span>;
        }
        
        System.out.print(<span class="string">"List: "</span>);
        <span class="classname">ListNode</span> current = head;
        <span class="keyword">while</span> (current != <span class="keyword">null</span>) {
            System.out.print(current.data);
            <span class="keyword">if</span> (current.next != <span class="keyword">null</span>) {
                System.out.print(<span class="string">" -> "</span>);
            }
            current = current.next;
        }
        System.out.println(<span class="string">" -> null"</span>);
    }
    
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">size</span>() { <span class="keyword">return</span> size; }
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() { <span class="keyword">return</span> head == <span class="keyword">null</span>; }
}</code></pre>
            </div>

            <h2>🔄 Doubly Linked List Implementation</h2>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Doubly Linked List Node</span>
<span class="keyword">class</span> <span class="classname">DoublyListNode</span> {
    <span class="type">int</span> data;
    <span class="classname">DoublyListNode</span> next;
    <span class="classname">DoublyListNode</span> prev;
    
    <span class="function">DoublyListNode</span>(<span class="type">int</span> data) {
        <span class="keyword">this</span>.data = data;
        <span class="keyword">this</span>.next = <span class="keyword">null</span>;
        <span class="keyword">this</span>.prev = <span class="keyword">null</span>;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">DoublyLinkedList</span> {
    <span class="keyword">private</span> <span class="classname">DoublyListNode</span> head;
    <span class="keyword">private</span> <span class="classname">DoublyListNode</span> tail;
    <span class="keyword">private</span> <span class="type">int</span> size;
    
    <span class="keyword">public</span> <span class="function">DoublyLinkedList</span>() {
        head = tail = <span class="keyword">null</span>;
        size = <span class="number">0</span>;
    }
    
    <span class="comment">// Insert at beginning - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertFirst</span>(<span class="type">int</span> data) {
        <span class="classname">DoublyListNode</span> newNode = <span class="keyword">new</span> <span class="classname">DoublyListNode</span>(data);
        
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            head = tail = newNode;
        } <span class="keyword">else</span> {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
        size<span class="operator">++</span>;
    }
    
    <span class="comment">// Insert at end - O(1)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertLast</span>(<span class="type">int</span> data) {
        <span class="classname">DoublyListNode</span> newNode = <span class="keyword">new</span> <span class="classname">DoublyListNode</span>(data);
        
        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) {
            head = tail = newNode;
        } <span class="keyword">else</span> {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        size<span class="operator">++</span>;
    }
    
    <span class="comment">// Remove first - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">removeFirst</span>() {
        <span class="keyword">if</span> (head == <span class="keyword">null</span>) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"List is empty"</span>);
        }
        
        <span class="type">int</span> data = head.data;
        head = head.next;
        
        <span class="keyword">if</span> (head != <span class="keyword">null</span>) {
            head.prev = <span class="keyword">null</span>;
        } <span class="keyword">else</span> {
            tail = <span class="keyword">null</span>;
        }
        size<span class="operator">--</span>;
        <span class="keyword">return</span> data;
    }
    
    <span class="comment">// Remove last - O(1)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">removeLast</span>() {
        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) {
            <span class="keyword">throw new</span> <span class="classname">RuntimeException</span>(<span class="string">"List is empty"</span>);
        }
        
        <span class="type">int</span> data = tail.data;
        tail = tail.prev;
        
        <span class="keyword">if</span> (tail != <span class="keyword">null</span>) {
            tail.next = <span class="keyword">null</span>;
        } <span class="keyword">else</span> {
            head = <span class="keyword">null</span>;
        }
        size<span class="operator">--</span>;
        <span class="keyword">return</span> data;
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>📋 Common Use Cases</h4>
                <ul>
                    <li><strong>Music Playlists:</strong> Next/Previous song functionality</li>
                    <li><strong>Browser History:</strong> Back/Forward navigation</li>
                    <li><strong>Undo/Redo Operations:</strong> Text editors, image editors</li>
                    <li><strong>Implementation of Stacks/Queues:</strong> Dynamic memory allocation</li>
                    <li><strong>Graph Adjacency Lists:</strong> Representing graph connections</li>
                    <li><strong>Memory Management:</strong> Free block lists in operating systems</li>
                </ul>
            </div>

            <h3>Example: Music Playlist Manager</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">MusicPlaylist</span> {
    <span class="keyword">private</span> <span class="classname">DoublyListNode</span> currentSong;
    <span class="keyword">private</span> <span class="classname">DoublyLinkedList</span> playlist;
    
    <span class="keyword">public</span> <span class="function">MusicPlaylist</span>() {
        playlist = <span class="keyword">new</span> <span class="classname">DoublyLinkedList</span>();
        currentSong = <span class="keyword">null</span>;
    }
    
    <span class="comment">// Add song to playlist</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">addSong</span>(<span class="classname">String</span> songTitle) {
        <span class="comment">// Using song title hash as data for simplicity</span>
        <span class="type">int</span> songId = songTitle.hashCode();
        playlist.insertLast(songId);
        
        <span class="keyword">if</span> (currentSong == <span class="keyword">null</span>) {
            currentSong = playlist.head;
        }
        System.out.println(<span class="string">"Added: "</span> <span class="operator">+</span> songTitle);
    }
    
    <span class="comment">// Play next song</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">nextSong</span>() {
        <span class="keyword">if</span> (currentSong != <span class="keyword">null</span> && currentSong.next != <span class="keyword">null</span>) {
            currentSong = currentSong.next;
            System.out.println(<span class="string">"Playing next song: "</span> <span class="operator">+</span> currentSong.data);
        } <span class="keyword">else</span> {
            System.out.println(<span class="string">"End of playlist"</span>);
        }
    }
    
    <span class="comment">// Play previous song</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">previousSong</span>() {
        <span class="keyword">if</span> (currentSong != <span class="keyword">null</span> && currentSong.prev != <span class="keyword">null</span>) {
            currentSong = currentSong.prev;
            System.out.println(<span class="string">"Playing previous song: "</span> <span class="operator">+</span> currentSong.data);
        } <span class="keyword">else</span> {
            System.out.println(<span class="string">"Already at beginning"</span>);
        }
    }
    
    <span class="comment">// Shuffle playlist</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">shuffle</span>() {
        System.out.println(<span class="string">"Playlist shuffled"</span>);
    }
}</code></pre>
            </div>

            <h2>📊 Time and Space Complexity</h2>
            <div class="highlight-box">
                <h4>⚡ Complexity Analysis</h4>
                <ul>
                    <li><strong>Insert at beginning:</strong> O(1) - Direct head manipulation</li>
                    <li><strong>Insert at end:</strong> O(n) for singly, O(1) for doubly</li>
                    <li><strong>Delete at beginning:</strong> O(1) - Direct head manipulation</li>
                    <li><strong>Delete at end:</strong> O(n) for singly, O(1) for doubly</li>
                    <li><strong>Search:</strong> O(n) - Linear traversal required</li>
                    <li><strong>Access by index:</strong> O(n) - No random access</li>
                    <li><strong>Space Complexity:</strong> O(n) - Extra space for pointers</li>
                </ul>
            </div>

            <h2>⚖️ Linked Lists vs Arrays</h2>
            <div class="code-example">
                <div class="code-language">Comparison</div>
                <pre><code><span class="comment">// Linked Lists Advantages</span>
<span class="keyword">✅ Dynamic Size:</span> Can grow/shrink during runtime
<span class="keyword">✅ Efficient Insertion/Deletion:</span> O(1) at known positions
<span class="keyword">✅ Memory Efficient:</span> Only allocates what's needed
<span class="keyword">✅ No Memory Waste:</span> No pre-allocated unused space

<span class="comment">// Linked Lists Disadvantages</span>
<span class="keyword">❌ No Random Access:</span> Must traverse from head
<span class="keyword">❌ Extra Memory:</span> Pointer storage overhead
<span class="keyword">❌ Cache Performance:</span> Non-contiguous memory
<span class="keyword">❌ Complex Implementation:</span> Pointer management</code></pre>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Reverse Linked List</a>
                    <a href="#" class="practice-link">Merge Two Sorted Lists</a>
                    <a href="#" class="practice-link">Detect Cycle in List</a>
                    <a href="#" class="practice-link">Remove Nth Node from End</a>
                    <a href="#" class="practice-link">Find Middle of List</a>
                    <a href="#" class="practice-link">Palindrome Linked List</a>
                </div>
            </div>
        </div>

        <!-- Trees -->
        <div class="content-section" id="trees">
            <h1>🌳 Trees</h1>
            <p>
                A tree is a hierarchical data structure consisting of nodes connected by edges. It has a root node 
                and forms a parent-child relationship where each node can have multiple children but only one parent.
            </p>

            <div class="highlight-box">
                <h4>🌲 Tree Characteristics</h4>
                <p>Trees are acyclic connected graphs with exactly n-1 edges for n nodes, making them perfect for representing hierarchical relationships.</p>
            </div>

            <h2>📋 Tree Terminology</h2>
            <div class="code-example">
                <div class="code-language">Terminology</div>
                <pre><code><span class="comment">// Tree Terminology</span>
<span class="keyword">Root:</span> Top node with no parent
<span class="keyword">Parent:</span> Node that has children
<span class="keyword">Child:</span> Node that has a parent
<span class="keyword">Leaf:</span> Node with no children
<span class="keyword">Height:</span> Length of longest path from root to leaf
<span class="keyword">Depth:</span> Length of path from root to specific node
<span class="keyword">Level:</span> All nodes at same depth from root
<span class="keyword">Subtree:</span> Tree formed by a node and its descendants

<span class="comment">// Visual Representation</span>
       <span class="number">1</span>          ← Root (Level <span class="number">0</span>)
      ╱ ╲
     <span class="number">2</span>   <span class="number">3</span>        ← Level <span class="number">1</span>
    ╱ ╲   ╲
   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>      ← Level <span class="number">2</span> (Leaves)
   
Height = <span class="number">2</span>, Nodes = <span class="number">6</span>, Edges = <span class="number">5</span></code></pre>
            </div>

            <h2>🔢 Binary Tree Types</h2>
            <div class="highlight-box">
                <h4>🎯 Binary Tree Definition</h4>
                <p>A binary tree is a tree where each node has at most two children, referred to as left child and right child.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Types</div>
                <pre><code><span class="comment">// Binary Tree Types</span>

<span class="keyword">1. Full Binary Tree:</span>
   • Every node has 0 or 2 children
   • No node has only 1 child
   • Also called "Proper" or "Strict" Binary Tree

<span class="keyword">2. Complete Binary Tree:</span>
   • All levels filled except possibly the last
   • Last level filled from left to right
   • Used in heaps and heap sort

<span class="keyword">3. Perfect Binary Tree:</span>
   • All internal nodes have 2 children
   • All leaves are at the same level
   • Total nodes = 2^h - 1 (where h = height)

<span class="keyword">4. Balanced Binary Tree:</span>
   • Height difference between left and right subtrees ≤ 1
   • Ensures O(log n) operations
   • AVL and Red-Black trees are examples

<span class="keyword">5. Degenerate Tree:</span>
   • Each parent has only one child
   • Essentially becomes a linked list
   • Poor performance: O(n) for all operations</code></pre>
            </div>

            <h2>🛠️ Binary Tree Implementation</h2>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Binary Tree Node</span>
<span class="keyword">class</span> <span class="classname">TreeNode</span> {
    <span class="type">int</span> data;
    <span class="classname">TreeNode</span> left;
    <span class="classname">TreeNode</span> right;
    
    <span class="function">TreeNode</span>(<span class="type">int</span> data) {
        <span class="keyword">this</span>.data = data;
        <span class="keyword">this</span>.left = <span class="keyword">null</span>;
        <span class="keyword">this</span>.right = <span class="keyword">null</span>;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">BinaryTree</span> {
    <span class="classname">TreeNode</span> root;
    
    <span class="keyword">public</span> <span class="function">BinaryTree</span>() {
        root = <span class="keyword">null</span>;
    }
    
    <span class="comment">// Pre-order Traversal: Root -> Left -> Right</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">preorder</span>(<span class="classname">TreeNode</span> node) {
        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {
            System.out.print(node.data <span class="operator">+</span> <span class="string">" "</span>);
            preorder(node.left);
            preorder(node.right);
        }
    }
    
    <span class="comment">// In-order Traversal: Left -> Root -> Right</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">inorder</span>(<span class="classname">TreeNode</span> node) {
        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {
            inorder(node.left);
            System.out.print(node.data <span class="operator">+</span> <span class="string">" "</span>);
            inorder(node.right);
        }
    }
    
    <span class="comment">// Post-order Traversal: Left -> Right -> Root</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">postorder</span>(<span class="classname">TreeNode</span> node) {
        <span class="keyword">if</span> (node != <span class="keyword">null</span>) {
            postorder(node.left);
            postorder(node.right);
            System.out.print(node.data <span class="operator">+</span> <span class="string">" "</span>);
        }
    }
    
    <span class="comment">// Level-order Traversal (BFS)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">levelOrder</span>() {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;
        
        <span class="classname">Queue</span>&lt;<span class="classname">TreeNode</span>&gt; queue = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
        queue.offer(root);
        
        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="classname">TreeNode</span> node = queue.poll();
            System.out.print(node.data <span class="operator">+</span> <span class="string">" "</span>);
            
            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);
            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);
        }
    }
    
    <span class="comment">// Calculate height of tree</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">height</span>(<span class="classname">TreeNode</span> node) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="operator">-</span><span class="number">1</span>;
        <span class="keyword">return</span> <span class="number">1</span> <span class="operator">+</span> Math.max(height(node.left), height(node.right));
    }
    
    <span class="comment">// Count total nodes</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">countNodes</span>(<span class="classname">TreeNode</span> node) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">return</span> <span class="number">1</span> <span class="operator">+</span> countNodes(node.left) <span class="operator">+</span> countNodes(node.right);
    }
    
    <span class="comment">// Check if tree is balanced</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isBalanced</span>(<span class="classname">TreeNode</span> node) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;
        
        <span class="type">int</span> leftHeight = height(node.left);
        <span class="type">int</span> rightHeight = height(node.right);
        
        <span class="keyword">return</span> Math.abs(leftHeight <span class="operator">-</span> rightHeight) &lt;= <span class="number">1</span> &&
               isBalanced(node.left) && isBalanced(node.right);
    }
}</code></pre>
            </div>

            <h2>🔍 Binary Search Tree (BST)</h2>
            <div class="highlight-box">
                <h4>📐 BST Property</h4>
                <p>For every node: all values in left subtree < node value < all values in right subtree. This property enables efficient searching, insertion, and deletion.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">BinarySearchTree</span> {
    <span class="classname">TreeNode</span> root;
    
    <span class="comment">// Insert operation - O(log n) average, O(n) worst</span>
    <span class="keyword">public</span> <span class="classname">TreeNode</span> <span class="function">insert</span>(<span class="classname">TreeNode</span> root, <span class="type">int</span> data) {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="classname">TreeNode</span>(data);
        }
        
        <span class="keyword">if</span> (data &lt; root.data) {
            root.left = insert(root.left, data);
        } <span class="keyword">else if</span> (data &gt; root.data) {
            root.right = insert(root.right, data);
        }
        <span class="comment">// Duplicate values ignored</span>
        
        <span class="keyword">return</span> root;
    }
    
    <span class="comment">// Search operation - O(log n) average, O(n) worst</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">search</span>(<span class="classname">TreeNode</span> root, <span class="type">int</span> key) {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span> (root.data == key) <span class="keyword">return</span> <span class="keyword">true</span>;
        
        <span class="keyword">return</span> key &lt; root.data ? 
               search(root.left, key) : 
               search(root.right, key);
    }
    
    <span class="comment">// Find minimum value (leftmost node)</span>
    <span class="keyword">public</span> <span class="classname">TreeNode</span> <span class="function">findMin</span>(<span class="classname">TreeNode</span> root) {
        <span class="keyword">while</span> (root != <span class="keyword">null</span> && root.left != <span class="keyword">null</span>) {
            root = root.left;
        }
        <span class="keyword">return</span> root;
    }
    
    <span class="comment">// Find maximum value (rightmost node)</span>
    <span class="keyword">public</span> <span class="classname">TreeNode</span> <span class="function">findMax</span>(<span class="classname">TreeNode</span> root) {
        <span class="keyword">while</span> (root != <span class="keyword">null</span> && root.right != <span class="keyword">null</span>) {
            root = root.right;
        }
        <span class="keyword">return</span> root;
    }
    
    <span class="comment">// Delete operation - O(log n) average, O(n) worst</span>
    <span class="keyword">public</span> <span class="classname">TreeNode</span> <span class="function">delete</span>(<span class="classname">TreeNode</span> root, <span class="type">int</span> key) {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;
        
        <span class="keyword">if</span> (key &lt; root.data) {
            root.left = delete(root.left, key);
        } <span class="keyword">else if</span> (key &gt; root.data) {
            root.right = delete(root.right, key);
        } <span class="keyword">else</span> {
            <span class="comment">// Node to delete found</span>
            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;
            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;
            
            <span class="comment">// Node has two children - find inorder successor</span>
            <span class="classname">TreeNode</span> minRight = findMin(root.right);
            root.data = minRight.data;
            root.right = delete(root.right, minRight.data);
        }
        <span class="keyword">return</span> root;
    }
    
    <span class="comment">// Validate if tree is a valid BST</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isValidBST</span>(<span class="classname">TreeNode</span> root) {
        <span class="keyword">return</span> isValidBST(root, <span class="classname">Long</span>.MIN_VALUE, <span class="classname">Long</span>.MAX_VALUE);
    }
    
    <span class="keyword">private</span> <span class="type">boolean</span> <span class="function">isValidBST</span>(<span class="classname">TreeNode</span> root, <span class="type">long</span> min, <span class="type">long</span> max) {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;
        
        <span class="keyword">if</span> (root.data &lt;= min || root.data >= max) <span class="keyword">return</span> <span class="keyword">false</span>;
        
        <span class="keyword">return</span> isValidBST(root.left, min, root.data) &&
               isValidBST(root.right, root.data, max);
    }
}</code></pre>
            </div>

            <h2>⚖️ AVL Trees (Self-Balancing BST)</h2>
            <div class="highlight-box">
                <h4>🔄 Balance Factor</h4>
                <p>AVL trees maintain balance by ensuring the height difference between left and right subtrees is at most 1 for every node.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// AVL Tree Node with height</span>
<span class="keyword">class</span> <span class="classname">AVLNode</span> {
    <span class="type">int</span> data;
    <span class="classname">AVLNode</span> left, right;
    <span class="type">int</span> height;
    
    <span class="function">AVLNode</span>(<span class="type">int</span> data) {
        <span class="keyword">this</span>.data = data;
        <span class="keyword">this</span>.height = <span class="number">1</span>;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">AVLTree</span> {
    
    <span class="comment">// Get height of node</span>
    <span class="type">int</span> <span class="function">height</span>(<span class="classname">AVLNode</span> node) {
        <span class="keyword">return</span> (node == <span class="keyword">null</span>) ? <span class="number">0</span> : node.height;
    }
    
    <span class="comment">// Get balance factor</span>
    <span class="type">int</span> <span class="function">getBalance</span>(<span class="classname">AVLNode</span> node) {
        <span class="keyword">return</span> (node == <span class="keyword">null</span>) ? <span class="number">0</span> : height(node.left) <span class="operator">-</span> height(node.right);
    }
    
    <span class="comment">// Right rotate (LL case)</span>
    <span class="classname">AVLNode</span> <span class="function">rightRotate</span>(<span class="classname">AVLNode</span> y) {
        <span class="classname">AVLNode</span> x = y.left;
        <span class="classname">AVLNode</span> T2 = x.right;
        
        <span class="comment">// Perform rotation</span>
        x.right = y;
        y.left = T2;
        
        <span class="comment">// Update heights</span>
        y.height = Math.max(height(y.left), height(y.right)) <span class="operator">+</span> <span class="number">1</span>;
        x.height = Math.max(height(x.left), height(x.right)) <span class="operator">+</span> <span class="number">1</span>;
        
        <span class="keyword">return</span> x; <span class="comment">// New root</span>
    }
    
    <span class="comment">// Left rotate (RR case)</span>
    <span class="classname">AVLNode</span> <span class="function">leftRotate</span>(<span class="classname">AVLNode</span> x) {
        <span class="classname">AVLNode</span> y = x.right;
        <span class="classname">AVLNode</span> T2 = y.left;
        
        <span class="comment">// Perform rotation</span>
        y.left = x;
        x.right = T2;
        
        <span class="comment">// Update heights</span>
        x.height = Math.max(height(x.left), height(x.right)) <span class="operator">+</span> <span class="number">1</span>;
        y.height = Math.max(height(y.left), height(y.right)) <span class="operator">+</span> <span class="number">1</span>;
        
        <span class="keyword">return</span> y; <span class="comment">// New root</span>
    }
    
    <span class="comment">// Insert with balancing</span>
    <span class="classname">AVLNode</span> <span class="function">insert</span>(<span class="classname">AVLNode</span> node, <span class="type">int</span> key) {
        <span class="comment">// Normal BST insertion</span>
        <span class="keyword">if</span> (node == <span class="keyword">null</span>)
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="classname">AVLNode</span>(key);
        
        <span class="keyword">if</span> (key &lt; node.data)
            node.left = insert(node.left, key);
        <span class="keyword">else if</span> (key &gt; node.data)
            node.right = insert(node.right, key);
        <span class="keyword">else</span> <span class="comment">// Duplicate keys not allowed</span>
            <span class="keyword">return</span> node;
        
        <span class="comment">// Update height</span>
        node.height = <span class="number">1</span> <span class="operator">+</span> Math.max(height(node.left), height(node.right));
        
        <span class="comment">// Get balance factor</span>
        <span class="type">int</span> balance = getBalance(node);
        
        <span class="comment">// Left Left Case</span>
        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> && key &lt; node.left.data)
            <span class="keyword">return</span> rightRotate(node);
        
        <span class="comment">// Right Right Case</span>
        <span class="keyword">if</span> (balance &lt; <span class="operator">-</span><span class="number">1</span> && key &gt; node.right.data)
            <span class="keyword">return</span> leftRotate(node);
        
        <span class="comment">// Left Right Case</span>
        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> && key &gt; node.left.data) {
            node.left = leftRotate(node.left);
            <span class="keyword">return</span> rightRotate(node);
        }
        
        <span class="comment">// Right Left Case</span>
        <span class="keyword">if</span> (balance &lt; <span class="operator">-</span><span class="number">1</span> && key &lt; node.right.data) {
            node.right = rightRotate(node.right);
            <span class="keyword">return</span> leftRotate(node);
        }
        
        <span class="keyword">return</span> node; <span class="comment">// No rotation needed</span>
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>📋 Common Use Cases</h4>
                <ul>
                    <li><strong>File Systems:</strong> Directory and folder structures</li>
                    <li><strong>Database Indexing:</strong> B-trees and B+ trees for efficient data retrieval</li>
                    <li><strong>Expression Parsing:</strong> Abstract syntax trees in compilers</li>
                    <li><strong>Decision Making:</strong> Decision trees in machine learning</li>
                    <li><strong>Network Routing:</strong> Shortest path algorithms</li>
                    <li><strong>HTML DOM:</strong> Document Object Model in web browsers</li>
                </ul>
            </div>

            <h3>Example: File System Explorer</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">FileSystemExplorer</span> {
    <span class="keyword">private</span> <span class="classname">BinarySearchTree</span> fileTree;
    
    <span class="keyword">public</span> <span class="function">FileSystemExplorer</span>() {
        fileTree = <span class="keyword">new</span> <span class="classname">BinarySearchTree</span>();
    }
    
    <span class="comment">// Add file to system</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">addFile</span>(<span class="classname">String</span> fileName) {
        <span class="type">int</span> fileId = fileName.hashCode();
        fileTree.root = fileTree.insert(fileTree.root, fileId);
        System.out.println(<span class="string">"Added file: "</span> <span class="operator">+</span> fileName);
    }
    
    <span class="comment">// Search for file</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">findFile</span>(<span class="classname">String</span> fileName) {
        <span class="type">int</span> fileId = fileName.hashCode();
        <span class="type">boolean</span> found = fileTree.search(fileTree.root, fileId);
        System.out.println(fileName <span class="operator">+</span> (found ? <span class="string">" found"</span> : <span class="string">" not found"</span>));
        <span class="keyword">return</span> found;
    }
    
    <span class="comment">// Delete file</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">deleteFile</span>(<span class="classname">String</span> fileName) {
        <span class="type">int</span> fileId = fileName.hashCode();
        fileTree.root = fileTree.delete(fileTree.root, fileId);
        System.out.println(<span class="string">"Deleted file: "</span> <span class="operator">+</span> fileName);
    }
    
    <span class="comment">// List all files in sorted order</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">listFiles</span>() {
        System.out.println(<span class="string">"Files in system:"</span>);
        fileTree.inorder(fileTree.root); <span class="comment">// Sorted output</span>
        System.out.println();
    }
}</code></pre>
            </div>

            <h2>📊 Time and Space Complexity</h2>
            <div class="highlight-box">
                <h4>⚡ Complexity Analysis</h4>
                <ul>
                    <li><strong>BST Search/Insert/Delete:</strong> O(log n) average, O(n) worst case</li>
                    <li><strong>AVL Search/Insert/Delete:</strong> O(log n) guaranteed</li>
                    <li><strong>Tree Traversal:</strong> O(n) - Visit all nodes</li>
                    <li><strong>Space Complexity:</strong> O(n) for storing nodes + O(h) for recursion stack</li>
                    <li><strong>BST vs Sorted Array:</strong> Insert/Delete O(log n) vs O(n)</li>
                </ul>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Validate Binary Search Tree</a>
                    <a href="#" class="practice-link">Lowest Common Ancestor</a>
                    <a href="#" class="practice-link">Binary Tree Level Order</a>
                    <a href="#" class="practice-link">Maximum Path Sum</a>
                    <a href="#" class="practice-link">Serialize/Deserialize Tree</a>
                    <a href="#" class="practice-link">Balance Binary Search Tree</a>
                </div>
            </div>
        </div>
        
        x.height = Math.max(height(x.left), height(x.right)) + 1;
        y.height = Math.max(height(y.left), height(y.right)) + 1;
        
        return y;
    }
}</div>
                </div>
                
                <div class="practice-section">
                    <h4>🏋️ Tree Problems</h4>
                    <div class="practice-links">
                        <a href="#" class="practice-link">Maximum Depth of Binary Tree</a>
                        <a href="#" class="practice-link">Validate Binary Search Tree</a>
                        <a href="#" class="practice-link">Lowest Common Ancestor</a>
                        <a href="#" class="practice-link">Binary Tree Level Order Traversal</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Huffman Coding -->
        <div class="content-section" id="huffman">
            <h1>🗜️ Huffman Coding Algorithm</h1>
            <p>
                Huffman Coding is a greedy algorithm used for optimal data compression. It assigns variable-length 
                codes to characters based on their frequency, with more frequent characters getting shorter codes.
            </p>

            <div class="highlight-box">
                <h4>🎯 Core Principle</h4>
                <p>Characters with higher frequency get shorter codes, and characters with lower frequency get longer codes, minimizing total compression size.</p>
            </div>

            <h2>📋 Algorithm Steps</h2>
            <div class="code-example">
                <div class="code-language">Process</div>
                <pre><code><span class="comment">// Huffman Algorithm Steps</span>

<span class="keyword">Step 1:</span> Count frequency of each character
<span class="keyword">Step 2:</span> Create leaf nodes for each character
<span class="keyword">Step 3:</span> Build min-heap based on frequencies
<span class="keyword">Step 4:</span> Repeat until one node remains:
   • Extract two nodes with minimum frequency
   • Create new internal node with these as children
   • Frequency = sum of children frequencies
   • Insert back into min-heap
<span class="keyword">Step 5:</span> Root of final tree is the Huffman Tree
<span class="keyword">Step 6:</span> Assign codes: left = 0, right = 1

<span class="comment">// Example: "ABACABAD"</span>
Character | Frequency | Huffman Code
    A     |     4     |      0
    B     |     3     |     10  
    C     |     1     |    110
    D     |     1     |    111

Original: 8 chars × 8 bits = 64 bits
Huffman:  4×1 + 3×2 + 1×3 + 1×3 = 19 bits
Compression ratio: 70% reduction!</code></pre>
            </div>

            <h2>🛠️ Implementation</h2>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Huffman Node Class</span>
<span class="keyword">class</span> <span class="classname">HuffmanNode</span> <span class="keyword">implements</span> <span class="classname">Comparable</span>&lt;<span class="classname">HuffmanNode</span>&gt; {
    <span class="type">int</span> frequency;
    <span class="type">char</span> character;
    <span class="classname">HuffmanNode</span> left, right;
    
    <span class="comment">// Constructor for leaf nodes</span>
    <span class="keyword">public</span> <span class="function">HuffmanNode</span>(<span class="type">char</span> character, <span class="type">int</span> frequency) {
        <span class="keyword">this</span>.character = character;
        <span class="keyword">this</span>.frequency = frequency;
        <span class="keyword">this</span>.left = <span class="keyword">null</span>;
        <span class="keyword">this</span>.right = <span class="keyword">null</span>;
    }
    
    <span class="comment">// Constructor for internal nodes</span>
    <span class="keyword">public</span> <span class="function">HuffmanNode</span>(<span class="type">int</span> frequency, <span class="classname">HuffmanNode</span> left, <span class="classname">HuffmanNode</span> right) {
        <span class="keyword">this</span>.character = <span class="string">'\0'</span>; <span class="comment">// Internal node has no character</span>
        <span class="keyword">this</span>.frequency = frequency;
        <span class="keyword">this</span>.left = left;
        <span class="keyword">this</span>.right = right;
    }
    
    <span class="comment">// For priority queue ordering (min-heap)</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">compareTo</span>(<span class="classname">HuffmanNode</span> other) {
        <span class="keyword">return</span> <span class="classname">Integer</span>.compare(<span class="keyword">this</span>.frequency, other.frequency);
    }
    
    <span class="comment">// Check if node is leaf</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isLeaf</span>() {
        <span class="keyword">return</span> left == <span class="keyword">null</span> && right == <span class="keyword">null</span>;
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">HuffmanCoding</span> {
    
    <span class="comment">// Build Huffman Tree</span>
    <span class="keyword">public</span> <span class="classname">HuffmanNode</span> <span class="function">buildHuffmanTree</span>(<span class="classname">String</span> text) {
        <span class="comment">// Step 1: Count character frequencies</span>
        <span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">Integer</span>&gt; freqMap = <span class="keyword">new</span> <span class="classname">HashMap</span>&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">char</span> c : text.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);
        }
        
        <span class="comment">// Step 2: Create priority queue (min-heap)</span>
        <span class="classname">PriorityQueue</span>&lt;<span class="classname">HuffmanNode</span>&gt; pq = <span class="keyword">new</span> <span class="classname">PriorityQueue</span>&lt;&gt;();
        
        <span class="comment">// Step 3: Create leaf nodes and add to queue</span>
        <span class="keyword">for</span> (<span class="classname">Map</span>.<span class="classname">Entry</span>&lt;<span class="classname">Character</span>, <span class="classname">Integer</span>&gt; entry : freqMap.entrySet()) {
            pq.offer(<span class="keyword">new</span> <span class="classname">HuffmanNode</span>(entry.getKey(), entry.getValue()));
        }
        
        <span class="comment">// Edge case: single character</span>
        <span class="keyword">if</span> (pq.size() == <span class="number">1</span>) {
            <span class="classname">HuffmanNode</span> single = pq.poll();
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="classname">HuffmanNode</span>(single.frequency, single, <span class="keyword">null</span>);
        }
        
        <span class="comment">// Step 4: Build tree bottom-up</span>
        <span class="keyword">while</span> (pq.size() > <span class="number">1</span>) {
            <span class="classname">HuffmanNode</span> left = pq.poll();  <span class="comment">// Lowest frequency</span>
            <span class="classname">HuffmanNode</span> right = pq.poll(); <span class="comment">// Second lowest</span>
            
            <span class="comment">// Create new internal node</span>
            <span class="type">int</span> mergedFreq = left.frequency + right.frequency;
            <span class="classname">HuffmanNode</span> merged = <span class="keyword">new</span> <span class="classname">HuffmanNode</span>(mergedFreq, left, right);
            
            pq.offer(merged);
        }
        
        <span class="keyword">return</span> pq.poll(); <span class="comment">// Root of Huffman tree</span>
    }
    
    <span class="comment">// Generate Huffman codes</span>
    <span class="keyword">public</span> <span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; <span class="function">generateCodes</span>(<span class="classname">HuffmanNode</span> root) {
        <span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; codes = <span class="keyword">new</span> <span class="classname">HashMap</span>&lt;&gt;();
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> codes;
        
        <span class="comment">// Handle single character case</span>
        <span class="keyword">if</span> (root.isLeaf()) {
            codes.put(root.character, <span class="string">"0"</span>);
            <span class="keyword">return</span> codes;
        }
        
        generateCodesHelper(root, <span class="string">""</span>, codes);
        <span class="keyword">return</span> codes;
    }
    
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">generateCodesHelper</span>(<span class="classname">HuffmanNode</span> node, <span class="classname">String</span> code, 
                                <span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; codes) {
        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;
        
        <span class="comment">// If leaf node, store the code</span>
        <span class="keyword">if</span> (node.isLeaf()) {
            codes.put(node.character, code.isEmpty() ? <span class="string">"0"</span> : code);
            <span class="keyword">return</span>;
        }
        
        <span class="comment">// Recurse: left = "0", right = "1"</span>
        generateCodesHelper(node.left, code + <span class="string">"0"</span>, codes);
        generateCodesHelper(node.right, code + <span class="string">"1"</span>, codes);
    }
    
    <span class="comment">// Encode text using Huffman codes</span>
    <span class="keyword">public</span> <span class="classname">String</span> <span class="function">encode</span>(<span class="classname">String</span> text, <span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; codes) {
        <span class="classname">StringBuilder</span> encoded = <span class="keyword">new</span> <span class="classname">StringBuilder</span>();
        <span class="keyword">for</span> (<span class="type">char</span> c : text.toCharArray()) {
            encoded.append(codes.get(c));
        }
        <span class="keyword">return</span> encoded.toString();
    }
    
    <span class="comment">// Decode binary string using Huffman tree</span>
    <span class="keyword">public</span> <span class="classname">String</span> <span class="function">decode</span>(<span class="classname">String</span> encodedText, <span class="classname">HuffmanNode</span> root) {
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;
        
        <span class="classname">StringBuilder</span> decoded = <span class="keyword">new</span> <span class="classname">StringBuilder</span>();
        <span class="classname">HuffmanNode</span> current = root;
        
        <span class="keyword">for</span> (<span class="type">char</span> bit : encodedText.toCharArray()) {
            <span class="keyword">if</span> (bit == <span class="string">'0'</span>) {
                current = current.left;
            } <span class="keyword">else</span> {
                current = current.right;
            }
            
            <span class="comment">// If leaf node, add character and reset to root</span>
            <span class="keyword">if</span> (current.isLeaf()) {
                decoded.append(current.character);
                current = root;
            }
        }
        
        <span class="keyword">return</span> decoded.toString();
    }
    
    <span class="comment">// Print Huffman codes</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">printCodes</span>(<span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; codes) {
        System.out.println(<span class="string">"Huffman Codes:"</span>);
        <span class="keyword">for</span> (<span class="classname">Map</span>.<span class="classname">Entry</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; entry : codes.entrySet()) {
            System.out.println(<span class="string">"'"</span> + entry.getKey() + <span class="string">"': "</span> + entry.getValue());
        }
    }
}</code></pre>
            </div>

            <h2>📊 Example Walkthrough</h2>
            <div class="code-example">
                <div class="code-language">Example</div>
                <pre><code><span class="comment">// Input text: "ABACABAD"</span>

<span class="keyword">Step 1: Frequency Count</span>
A: <span class="number">4</span> occurrences
B: <span class="number">3</span> occurrences  
C: <span class="number">1</span> occurrence
D: <span class="number">1</span> occurrence

<span class="keyword">Step 2: Initial Priority Queue</span>
[C:1] [D:1] [B:3] [A:4]

<span class="keyword">Step 3: Build Tree</span>
1. Merge C(<span class="number">1</span>) + D(<span class="number">1</span>) = Internal(<span class="number">2</span>)
   Queue: [Internal:2] [B:3] [A:4]

2. Merge Internal(<span class="number">2</span>) + B(<span class="number">3</span>) = Internal(<span class="number">5</span>)
   Queue: [A:4] [Internal:5]

3. Merge A(<span class="number">4</span>) + Internal(<span class="number">5</span>) = Root(<span class="number">9</span>)

<span class="keyword">Final Tree Structure:</span>
        Root(9)
       /        \
    A(4)      Internal(5)
              /         \
           B(3)      Internal(2)
                     /         \
                  C(1)       D(1)

<span class="keyword">Generated Codes:</span>
A: <span class="string">"0"</span>      (1 bit)
B: <span class="string">"10"</span>     (2 bits)  
C: <span class="string">"110"</span>    (3 bits)
D: <span class="string">"111"</span>    (3 bits)

<span class="keyword">Encoding "ABACABAD":</span>
A B A C A B A D
<span class="string">"0 10 0 110 0 10 0 111"</span>
Result: <span class="string">"010011001000111"</span> (19 bits vs 64 bits original)</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>💾 Compression Uses</h4>
                <ul>
                    <li><strong>File Compression:</strong> ZIP, GZIP, PNG image compression</li>
                    <li><strong>Data Transmission:</strong> Reducing bandwidth in networks</li>
                    <li><strong>Multimedia:</strong> JPEG (modified Huffman), MP3 encoding</li>
                    <li><strong>Database Storage:</strong> Compressing frequently accessed data</li>
                    <li><strong>Network Protocols:</strong> HTTP/2 header compression</li>
                </ul>
            </div>

            <h3>Example: File Compression System</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">FileCompressor</span> {
    <span class="keyword">private</span> <span class="classname">HuffmanCoding</span> huffman;
    
    <span class="keyword">public</span> <span class="function">FileCompressor</span>() {
        huffman = <span class="keyword">new</span> <span class="classname">HuffmanCoding</span>();
    }
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">compressFile</span>(<span class="classname">String</span> inputFile, <span class="classname">String</span> outputFile) {
        <span class="keyword">try</span> {
            <span class="comment">// Read file content</span>
            <span class="classname">String</span> content = <span class="classname">Files</span>.readString(<span class="classname">Paths</span>.get(inputFile));
            
            <span class="comment">// Build Huffman tree and generate codes</span>
            <span class="classname">HuffmanNode</span> root = huffman.buildHuffmanTree(content);
            <span class="classname">Map</span>&lt;<span class="classname">Character</span>, <span class="classname">String</span>&gt; codes = huffman.generateCodes(root);
            
            <span class="comment">// Encode content</span>
            <span class="classname">String</span> encoded = huffman.encode(content, codes);
            
            <span class="comment">// Calculate compression statistics</span>
            <span class="type">int</span> originalBits = content.length() * <span class="number">8</span>; <span class="comment">// ASCII = 8 bits per char</span>
            <span class="type">int</span> compressedBits = encoded.length();
            <span class="type">double</span> compressionRatio = <span class="number">100.0</span> * (<span class="number">1</span> - (<span class="type">double</span>)compressedBits / originalBits);
            
            System.out.println(<span class="string">"Original size: "</span> + originalBits + <span class="string">" bits"</span>);
            System.out.println(<span class="string">"Compressed size: "</span> + compressedBits + <span class="string">" bits"</span>);
            System.out.println(<span class="string">"Compression ratio: "</span> + 
                              <span class="classname">String</span>.format(<span class="string">"%.2f%%"</span>, compressionRatio));
            
            <span class="comment">// Save compressed data (would need binary writing in practice)</span>
            huffman.printCodes(codes);
            
        } <span class="keyword">catch</span> (<span class="classname">IOException</span> e) {
            System.err.println(<span class="string">"Error processing file: "</span> + e.getMessage());
        }
    }
}</code></pre>
            </div>

            <h2>📊 Time and Space Complexity</h2>
            <div class="highlight-box">
                <h4>⚡ Performance Analysis</h4>
                <ul>
                    <li><strong>Building Tree:</strong> O(n log n) where n is number of unique characters</li>
                    <li><strong>Generating Codes:</strong> O(n) to traverse tree</li>
                    <li><strong>Encoding:</strong> O(m) where m is length of input text</li>
                    <li><strong>Decoding:</strong> O(m) where m is length of encoded text</li>
                    <li><strong>Space Complexity:</strong> O(n) for tree and codes storage</li>
                </ul>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Implement File Compressor</a>
                    <a href="#" class="practice-link">Huffman Tree Reconstruction</a>
                    <a href="#" class="practice-link">Optimal Merge Pattern</a>
                    <a href="#" class="practice-link">Text Compression Analysis</a>
                </div>
            </div>
        </div>

        <!-- Sorting Algorithms -->
        <div class="content-section" id="sorting">
            <h1>🔄 Sorting Algorithms</h1>
            <p>
                Sorting algorithms arrange elements in a specific order (ascending or descending). Understanding different 
                sorting techniques helps choose the right algorithm based on data size, memory constraints, and performance requirements.
            </p>

            <div class="highlight-box">
                <h4>🎯 Sorting Categories</h4>
                <p>Comparison-based sorts compare elements to determine order, while non-comparison sorts use element properties like digit values or frequency.</p>
            </div>

            <h2>📊 Algorithm Comparison</h2>
            <div class="code-example">
                <div class="code-language">Performance Comparison</div>
                <pre><code><span class="comment">// Sorting Algorithm Performance Summary</span>

<span class="keyword">Algorithm</span>     | <span class="keyword">Best Case</span> | <span class="keyword">Average</span>  | <span class="keyword">Worst Case</span> | <span class="keyword">Space</span> | <span class="keyword">Stable</span>
<span class="operator">-----------</span>-+<span class="operator">-----------</span>+<span class="operator">---------</span>-+<span class="operator">-----------</span>+<span class="operator">-------</span>+<span class="operator">--------</span>
Selection    | O(n²)     | O(n²)    | O(n²)     | O(<span class="number">1</span>)   | No
Bubble       | O(n)      | O(n²)    | O(n²)     | O(<span class="number">1</span>)   | Yes
Insertion    | O(n)      | O(n²)    | O(n²)     | O(<span class="number">1</span>)   | Yes  
Merge        | O(n log n)| O(n log n)| O(n log n)| O(n)   | Yes
Quick        | O(n log n)| O(n log n)| O(n²)     | O(log n)| No
Heap         | O(n log n)| O(n log n)| O(n log n)| O(<span class="number">1</span>)   | No

<span class="keyword">When to Use:</span>
• <span class="function">Small datasets</span>: Insertion Sort
• <span class="function">Nearly sorted</span>: Insertion Sort, Bubble Sort
• <span class="function">Memory constrained</span>: Heap Sort, Quick Sort
• <span class="function">Stable required</span>: Merge Sort, Insertion Sort
• <span class="function">General purpose</span>: Quick Sort, Merge Sort</code></pre>
            </div>

            <h2>🔍 Selection Sort</h2>
            <div class="highlight-box">
                <h4>💡 Algorithm Principle</h4>
                <p>Find the minimum element from unsorted portion and place it at the beginning. Repeat until entire array is sorted.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Selection Sort Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">SelectionSort</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">selectionSort</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {
            <span class="type">int</span> minIndex = i;
            
            <span class="comment">// Find minimum element in remaining array</span>
            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) {
                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            <span class="comment">// Swap minimum element with first element</span>
            <span class="keyword">if</span> (minIndex != i) {
                <span class="function">swap</span>(arr, i, minIndex);
            }
        }
    }
    
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">swap</span>(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) {
        <span class="type">int</span> temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    <span class="comment">// Demonstration with step-by-step visualization</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">selectionSortVerbose</span>(<span class="type">int</span>[] arr) {
        System.out.println(<span class="string">"Initial array: "</span> + <span class="classname">Arrays</span>.toString(arr));
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) {
            <span class="type">int</span> minIndex = i;
            
            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) {
                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            <span class="keyword">if</span> (minIndex != i) {
                System.out.println(<span class="string">"Pass "</span> + (i + <span class="number">1</span>) + <span class="string">": Moving "</span> + arr[minIndex] + 
                                  <span class="string">" to position "</span> + i);
                <span class="function">swap</span>(arr, i, minIndex);
            }
            
            System.out.println(<span class="string">"After pass "</span> + (i + <span class="number">1</span>) + <span class="string">": "</span> + <span class="classname">Arrays</span>.toString(arr));
        }
    }
}</code></pre>
            </div>

            <h2>🫧 Bubble Sort</h2>
            <div class="highlight-box">
                <h4>🌊 Bubbling Effect</h4>
                <p>Repeatedly compares adjacent elements and swaps them if they're in wrong order. Largest elements "bubble up" to their correct positions.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Bubble Sort Implementation with Optimization</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">BubbleSort</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">bubbleSort</span>(<span class="type">int</span>[] arr) {until
        <span class="type">int</span> n = arr.length;
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {
            <span class="type">boolean</span> swapped = <span class="keyword">false</span>;
            
            <span class="comment">// Last i elements are already sorted</span>
            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) {
                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) {
                    <span class="comment">// Swap adjacent elements</span>
                    <span class="function">swap</span>(arr, j, j + <span class="number">1</span>);
                    swapped = <span class="keyword">true</span>;
                }
            }
            
            <span class="comment">// If no swapping occurred, array is sorted</span>
            <span class="keyword">if</span> (!swapped) {
                System.out.println(<span class="string">"Array sorted early at pass "</span> + (i + <span class="number">1</span>));
                <span class="keyword">break</span>;
            }
        }
    }
    
    <span class="comment">// Optimized version with early termination</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">optimizedBubbleSort</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        <span class="type">boolean</span> swapped;
        
        <span class="keyword">do</span> {
            swapped = <span class="keyword">false</span>;
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {
                <span class="keyword">if</span> (arr[i - <span class="number">1</span>] &gt; arr[i]) {
                    <span class="function">swap</span>(arr, i - <span class="number">1</span>, i);
                    swapped = <span class="keyword">true</span>;
                }
            }
            n--; <span class="comment">// Reduce the range as last element is sorted</span>
        } <span class="keyword">while</span> (swapped);
    }
    
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">swap</span>(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) {
        <span class="type">int</span> temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</code></pre>
            </div>

            <h2>📝 Insertion Sort</h2>
            <div class="highlight-box">
                <h4>🃏 Card Sorting Analogy</h4>
                <p>Like sorting playing cards in your hand - take each card and insert it into its correct position among the already sorted cards.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Insertion Sort Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">InsertionSort</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertionSort</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {
            <span class="type">int</span> key = arr[i];
            <span class="type">int</span> j = i - <span class="number">1</span>;
            
            <span class="comment">// Move elements greater than key one position ahead</span>
            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> && arr[j] &gt; key) {
                arr[j + <span class="number">1</span>] = arr[j];
                j--;
            }
            
            arr[j + <span class="number">1</span>] = key;
        }
    }
    
    <span class="comment">// Recursive version</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">insertionSortRecursive</span>(<span class="type">int</span>[] arr, <span class="type">int</span> n) {
        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;
        
        <span class="comment">// Sort first n-1 elements</span>
        insertionSortRecursive(arr, n - <span class="number">1</span>);
        
        <span class="comment">// Insert last element at its correct position</span>
        <span class="type">int</span> last = arr[n - <span class="number">1</span>];
        <span class="type">int</span> j = n - <span class="number">2</span>;
        
        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> && arr[j] &gt; last) {
            arr[j + <span class="number">1</span>] = arr[j];
            j--;
        }
        
        arr[j + <span class="number">1</span>] = last;
    }
    
    <span class="comment">// Binary Insertion Sort (optimized search)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">binaryInsertionSort</span>(<span class="type">int</span>[] arr) {
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {
            <span class="type">int</span> key = arr[i];
            <span class="type">int</span> insertPos = <span class="function">binarySearch</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>, key);
            
            <span class="comment">// Shift elements to make space</span>
            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; insertPos; j--) {
                arr[j] = arr[j - <span class="number">1</span>];
            }
            
            arr[insertPos] = key;
        }
    }
    
    <span class="keyword">private</span> <span class="type">int</span> <span class="function">binarySearch</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> key) {
        <span class="keyword">while</span> (low &lt;= high) {
            <span class="type">int</span> mid = low + (high - low) / <span class="number">2</span>;
            <span class="keyword">if</span> (arr[mid] &gt; key) {
                high = mid - <span class="number">1</span>;
            } <span class="keyword">else</span> {
                low = mid + <span class="number">1</span>;
            }
        }
        <span class="keyword">return</span> low;
    }
}</code></pre>
            </div>

            <h2>🔀 Merge Sort</h2>
            <div class="highlight-box">
                <h4>🧩 Divide and Conquer</h4>
                <p>Recursively divide the array into halves, sort each half, then merge the sorted halves back together. Guarantees O(n log n) performance.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Merge Sort Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">MergeSort</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">mergeSort</span>(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right) {
        <span class="keyword">if</span> (left &lt; right) {
            <span class="comment">// Find middle point to divide array into two halves</span>
            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;
            
            <span class="comment">// Recursively sort both halves</span>
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + <span class="number">1</span>, right);
            
            <span class="comment">// Merge the sorted halves</span>
            merge(arr, left, mid, right);
        }
    }
    
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">merge</span>(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right) {
        <span class="comment">// Create temporary arrays for left and right subarrays</span>
        <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;
        <span class="type">int</span> n2 = right - mid;
        
        <span class="type">int</span>[] leftArr = <span class="keyword">new</span> <span class="type">int</span>[n1];
        <span class="type">int</span>[] rightArr = <span class="keyword">new</span> <span class="type">int</span>[n2];
        
        <span class="comment">// Copy data to temporary arrays</span>
        <span class="classname">System</span>.arraycopy(arr, left, leftArr, <span class="number">0</span>, n1);
        <span class="classname">System</span>.arraycopy(arr, mid + <span class="number">1</span>, rightArr, <span class="number">0</span>, n2);
        
        <span class="comment">// Merge the temporary arrays back</span>
        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;
        
        <span class="keyword">while</span> (i &lt; n1 && j &lt; n2) {
            <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } <span class="keyword">else</span> {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }
        
        <span class="comment">// Copy remaining elements</span>
        <span class="keyword">while</span> (i &lt; n1) arr[k++] = leftArr[i++];
        <span class="keyword">while</span> (j &lt; n2) arr[k++] = rightArr[j++];
    }
    
    <span class="comment">// Iterative version (bottom-up approach)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">mergeSortIterative</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        
        <span class="comment">// Start with subarrays of size 1, double size in each iteration</span>
        <span class="keyword">for</span> (<span class="type">int</span> size = <span class="number">1</span>; size &lt; n; size *= <span class="number">2</span>) {
            <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>; left &lt; n - size; left += <span class="number">2</span> * size) {
                <span class="type">int</span> mid = left + size - <span class="number">1</span>;
                <span class="type">int</span> right = <span class="classname">Math</span>.min(left + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>);
                
                merge(arr, left, mid, right);
            }
        }
    }
}</code></pre>
            </div>

            <h2>⚡ Quick Sort</h2>
            <div class="highlight-box">
                <h4>🎯 Pivot Strategy</h4>
                <p>Choose a pivot element, partition array so smaller elements go left and larger go right, then recursively sort both parts.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Quick Sort Implementation with Multiple Pivot Strategies</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">QuickSort</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">quickSort</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high) {
        <span class="keyword">if</span> (low &lt; high) {
            <span class="comment">// Partition array and get pivot index</span>
            <span class="type">int</span> pi = partition(arr, low, high);
            
            <span class="comment">// Recursively sort elements before and after partition</span>
            quickSort(arr, low, pi - <span class="number">1</span>);
            quickSort(arr, pi + <span class="number">1</span>, high);
        }
    }
    
    <span class="comment">// Lomuto Partition (last element as pivot)</span>
    <span class="keyword">private</span> <span class="type">int</span> <span class="function">partition</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high) {
        <span class="type">int</span> pivot = arr[high]; <span class="comment">// Choose rightmost as pivot</span>
        <span class="type">int</span> i = low - <span class="number">1</span>; <span class="comment">// Index of smaller element</span>
        
        <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) {
            <span class="keyword">if</span> (arr[j] &lt; pivot) {
                i++;
                <span class="function">swap</span>(arr, i, j);
            }
        }
        
        <span class="function">swap</span>(arr, i + <span class="number">1</span>, high);
        <span class="keyword">return</span> i + <span class="number">1</span>;
    }
    
    <span class="comment">// Hoare Partition (more efficient)</span>
    <span class="keyword">private</span> <span class="type">int</span> <span class="function">hoarePartition</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high) {
        <span class="type">int</span> pivot = arr[low]; <span class="comment">// Choose first element as pivot</span>
        <span class="type">int</span> i = low - <span class="number">1</span>;
        <span class="type">int</span> j = high + <span class="number">1</span>;
        
        <span class="keyword">while</span> (<span class="keyword">true</span>) {
            <span class="keyword">do</span> { i++; } <span class="keyword">while</span> (arr[i] &lt; pivot);
            <span class="keyword">do</span> { j--; } <span class="keyword">while</span> (arr[j] &gt; pivot);
            
            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span> j;
            
            <span class="function">swap</span>(arr, i, j);
        }
    }
    
    <span class="comment">// Quick Sort with Random Pivot (avoid worst case)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">quickSortRandomized</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high) {
        <span class="keyword">if</span> (low &lt; high) {
            <span class="comment">// Randomize pivot to avoid worst case</span>
            <span class="type">int</span> randomIndex = low + <span class="keyword">new</span> <span class="classname">Random</span>().nextInt(high - low + <span class="number">1</span>);
            <span class="function">swap</span>(arr, randomIndex, high);
            
            <span class="type">int</span> pi = partition(arr, low, high);
            quickSortRandomized(arr, low, pi - <span class="number">1</span>);
            quickSortRandomized(arr, pi + <span class="number">1</span>, high);
        }
    }
    
    <span class="comment">// 3-Way Quick Sort (handles duplicates efficiently)</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">quickSort3Way</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high) {
        <span class="keyword">if</span> (low &lt; high) {
            <span class="type">int</span>[] pivots = partition3Way(arr, low, high);
            quickSort3Way(arr, low, pivots[<span class="number">0</span>] - <span class="number">1</span>);
            quickSort3Way(arr, pivots[<span class="number">1</span>] + <span class="number">1</span>, high);
        }
    }
    
    <span class="keyword">private</span> <span class="type">int</span>[] <span class="function">partition3Way</span>(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high) {
        <span class="type">int</span> pivot = arr[low];
        <span class="type">int</span> lt = low; <span class="comment">// less than pivot</span>
        <span class="type">int</span> gt = high; <span class="comment">// greater than pivot</span>
        <span class="type">int</span> i = low + <span class="number">1</span>; <span class="comment">// current element</span>
        
        <span class="keyword">while</span> (i &lt;= gt) {
            <span class="keyword">if</span> (arr[i] &lt; pivot) {
                <span class="function">swap</span>(arr, i++, lt++);
            } <span class="keyword">else if</span> (arr[i] &gt; pivot) {
                <span class="function">swap</span>(arr, i, gt--);
            } <span class="keyword">else</span> {
                i++;
            }
        }
        
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">int</span>[]{lt, gt};
    }
    
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">swap</span>(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) {
        <span class="type">int</span> temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</code></pre>
            </div>

            <h2>🏔️ Heap Sort</h2>
            <div class="highlight-box">
                <h4>🌳 Binary Heap Structure</h4>
                <p>Uses a binary heap data structure where parent nodes are larger (max-heap) or smaller (min-heap) than their children. Guarantees O(n log n) performance.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Heap Sort Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">HeapSort</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">heapSort</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        
        <span class="comment">// Build max heap (rearrange array)</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
            heapify(arr, n, i);
        }
        
        <span class="comment">// Extract elements from heap one by one</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {
            <span class="comment">// Move current root to end</span>
            <span class="function">swap</span>(arr, <span class="number">0</span>, i);
            
            <span class="comment">// Heapify reduced heap</span>
            heapify(arr, i, <span class="number">0</span>);
        }
    }
    
    <span class="comment">// Maintain max heap property</span>
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">heapify</span>(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i) {
        <span class="type">int</span> largest = i; <span class="comment">// Initialize largest as root</span>
        <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// Left child</span>
        <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// Right child</span>
        
        <span class="comment">// If left child is larger than root</span>
        <span class="keyword">if</span> (left &lt; n && arr[left] &gt; arr[largest]) {
            largest = left;
        }
        
        <span class="comment">// If right child is larger than largest so far</span>
        <span class="keyword">if</span> (right &lt; n && arr[right] &gt; arr[largest]) {
            largest = right;
        }
        
        <span class="comment">// If largest is not root</span>
        <span class="keyword">if</span> (largest != i) {
            <span class="function">swap</span>(arr, i, largest);
            
            <span class="comment">// Recursively heapify affected sub-tree</span>
            heapify(arr, n, largest);
        }
    }
    
    <span class="comment">// Build heap iteratively</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">buildMaxHeap</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        
        <span class="comment">// Start from last non-leaf node and heapify</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = (n / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
            heapify(arr, n, i);
        }
    }
    
    <span class="comment">// Min heap version</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">minHeapify</span>(<span class="type">int</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> i) {
        <span class="type">int</span> smallest = i;
        <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;
        <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;
        
        <span class="keyword">if</span> (left &lt; n && arr[left] &lt; arr[smallest]) {
            smallest = left;
        }
        
        <span class="keyword">if</span> (right &lt; n && arr[right] &lt; arr[smallest]) {
            smallest = right;
        }
        
        <span class="keyword">if</span> (smallest != i) {
            <span class="function">swap</span>(arr, i, smallest);
            minHeapify(arr, n, smallest);
        }
    }
    
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">swap</span>(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j) {
        <span class="type">int</span> temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>🎯 When to Use Which Algorithm</h4>
                <ul>
                    <li><strong>Database Indexing:</strong> Merge Sort for external sorting of large datasets</li>
                    <li><strong>System Libraries:</strong> Introsort (hybrid of Quick Sort, Heap Sort, Insertion Sort)</li>
                    <li><strong>Graphics Processing:</strong> Radix Sort for sorting by color components</li>
                    <li><strong>Real-time Systems:</strong> Heap Sort for predictable O(n log n) performance</li>
                    <li><strong>Memory-constrained Devices:</strong> Quick Sort with O(log n) space</li>
                </ul>
            </div>

            <h3>Example: Smart Sorting System</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">SmartSortingSystem</span> {
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">smartSort</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> n = arr.length;
        
        <span class="comment">// Choose algorithm based on data characteristics</span>
        <span class="keyword">if</span> (n &lt; <span class="number">10</span>) {
            <span class="comment">// Use insertion sort for small arrays</span>
            <span class="keyword">new</span> <span class="classname">InsertionSort</span>().insertionSort(arr);
        } <span class="keyword">else if</span> (isNearlySorted(arr)) {
            <span class="comment">// Use insertion sort for nearly sorted arrays</span>
            <span class="keyword">new</span> <span class="classname">InsertionSort</span>().insertionSort(arr);
        } <span class="keyword">else if</span> (hasManyDuplicates(arr)) {
            <span class="comment">// Use 3-way quicksort for many duplicates</span>
            <span class="keyword">new</span> <span class="classname">QuickSort</span>().quickSort3Way(arr, <span class="number">0</span>, n - <span class="number">1</span>);
        } <span class="keyword">else if</span> (memoryConstrained()) {
            <span class="comment">// Use heap sort for guaranteed O(1) space</span>
            <span class="keyword">new</span> <span class="classname">HeapSort</span>().heapSort(arr);
        } <span class="keyword">else</span> {
            <span class="comment">// Use merge sort for stable, guaranteed O(n log n)</span>
            <span class="keyword">new</span> <span class="classname">MergeSort</span>().mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);
        }
    }
    
    <span class="keyword">private</span> <span class="type">boolean</span> <span class="function">isNearlySorted</span>(<span class="type">int</span>[] arr) {
        <span class="type">int</span> inversions = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) {
            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) {
                inversions++;
                <span class="keyword">if</span> (inversions &gt; arr.length / <span class="number">4</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
            }
        }
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }
    
    <span class="keyword">private</span> <span class="type">boolean</span> <span class="function">hasManyDuplicates</span>(<span class="type">int</span>[] arr) {
        <span class="classname">Set</span>&lt;<span class="classname">Integer</span>&gt; unique = <span class="keyword">new</span> <span class="classname">HashSet</span>&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> num : arr) {
            unique.add(num);
        }
        <span class="keyword">return</span> unique.size() &lt; arr.length / <span class="number">2</span>;
    }
    
    <span class="keyword">private</span> <span class="type">boolean</span> <span class="function">memoryConstrained</span>() {
        <span class="comment">// Check available memory</span>
        <span class="keyword">long</span> freeMemory = <span class="classname">Runtime</span>.getRuntime().freeMemory();
        <span class="keyword">long</span> totalMemory = <span class="classname">Runtime</span>.getRuntime().totalMemory();
        <span class="keyword">return</span> freeMemory &lt; totalMemory * <span class="number">0.1</span>; <span class="comment">// Less than 10% free</span>
    }
}</code></pre>
            </div>

            <h2>📊 Performance Analysis</h2>
            <div class="highlight-box">
                <h4>⚡ Algorithm Selection Guide</h4>
                <ul>
                    <li><strong>Best Overall:</strong> Merge Sort (stable, predictable O(n log n))</li>
                    <li><strong>Average Case Winner:</strong> Quick Sort (fastest in practice)</li>
                    <li><strong>Space Efficient:</strong> Heap Sort (O(1) extra space)</li>
                    <li><strong>Small Arrays:</strong> Insertion Sort (low overhead)</li>
                    <li><strong>Nearly Sorted:</strong> Insertion Sort or Bubble Sort</li>
                </ul>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Sort Colors (Dutch Flag)</a>
                    <a href="#" class="practice-link">Merge Intervals</a>
                    <a href="#" class="practice-link">Largest Number Formation</a>
                    <a href="#" class="practice-link">Sort Linked List</a>
                    <a href="#" class="practice-link">Kth Largest Element</a>
                    <a href="#" class="practice-link">Custom Comparator Sort</a>
                </div>
            </div>
        </div>

        <!-- Searching Algorithms -->
        <div class="content-section" id="searching">
            <h1>🔍 Searching Algorithms</h1>
            <p>
                Searching algorithms find specific elements within data structures. Understanding different search techniques 
                helps choose the right approach based on data organization, size constraints, and performance requirements.
            </p>

            <div class="highlight-box">
                <h4>🎯 Search Strategy Categories</h4>
                <p>Linear searches examine elements sequentially, while logarithmic searches use data structure properties to eliminate large portions of the search space.</p>
            </div>

            <h2>📊 Algorithm Comparison</h2>
            <div class="code-example">
                <div class="code-language">Performance Analysis</div>
                <pre><code><span class="comment">// Searching Algorithm Performance Summary</span>

<span class="keyword">Algorithm</span>      | <span class="keyword">Time Complexity</span>  | <span class="keyword">Space</span> | <span class="keyword">Prerequisites</span>    | <span class="keyword">Best Use Case</span>
<span class="operator">-------------</span>+<span class="operator">-----------------</span>+<span class="operator">-------</span>+<span class="operator">----------------</span>+<span class="operator">------------------</span>
Linear Search   | O(n)            | O(<span class="number">1</span>)   | None           | Unsorted data
Binary Search   | O(log n)        | O(<span class="number">1</span>)   | Sorted array   | Large sorted datasets
Hash Table      | O(<span class="number">1</span>) average    | O(n)   | Hash function  | Key-based lookups
Binary Trees    | O(log n)        | O(n)   | Balanced tree  | Dynamic datasets

<span class="keyword">When to Use:</span>
• <span class="function">Small datasets</span>: Linear Search (simple, no preprocessing)
• <span class="function">Large sorted data</span>: Binary Search (logarithmic performance)
• <span class="function">Frequent searches</span>: Hash Tables (constant average time)
• <span class="function">Dynamic data</span>: Self-balancing trees (insertion + search)
• <span class="function">Range queries</span>: Binary Search Trees with modifications</code></pre>
            </div>

            <h2>🔍 Linear Search (Sequential Search)</h2>
            <div class="highlight-box">
                <h4>💡 Algorithm Principle</h4>
                <p>Examine each element sequentially until the target is found or all elements are checked. Simple but guaranteed to find the element if it exists.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Linear Search Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">LinearSearch</span> {
    
    <span class="comment">// Basic Linear Search</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">linearSearch</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target) {
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
            <span class="keyword">if</span> (arr[i] == target) {
                <span class="keyword">return</span> i; <span class="comment">// Return index if found</span>
            }
        }
        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Return -1 if not found</span>
    }
    
    <span class="comment">// Recursive Linear Search</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">linearSearchRecursive</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target, <span class="type">int</span> index) {
        <span class="comment">// Base case: reached end of array</span>
        <span class="keyword">if</span> (index &gt;= arr.length) <span class="keyword">return</span> -<span class="number">1</span>;
        
        <span class="comment">// Found target at current index</span>
        <span class="keyword">if</span> (arr[index] == target) <span class="keyword">return</span> index;
        
        <span class="comment">// Recursively search remaining elements</span>
        <span class="keyword">return</span> linearSearchRecursive(arr, target, index + <span class="number">1</span>);
    }
    
    <span class="comment">// Find all occurrences of target</span>
    <span class="keyword">public</span> <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; <span class="function">findAllOccurrences</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target) {
        <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; indices = <span class="keyword">new</span> <span class="classname">ArrayList</span>&lt;&gt;();
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
            <span class="keyword">if</span> (arr[i] == target) {
                indices.add(i);
            }
        }
        
        <span class="keyword">return</span> indices;
    }
    
    <span class="comment">// Generic linear search for any type</span>
    <span class="keyword">public</span> &lt;T&gt; <span class="type">int</span> <span class="function">linearSearchGeneric</span>(T[] arr, T target) {
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
            <span class="keyword">if</span> (arr[i] != <span class="keyword">null</span> && arr[i].equals(target)) {
                <span class="keyword">return</span> i;
            }
        }
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
}</code></pre>
            </div>

            <h2>🎯 Binary Search</h2>
            <div class="highlight-box">
                <h4>📖 Divide and Conquer Approach</h4>
                <p>Repeatedly divide the search interval in half by comparing the target with the middle element. Requires sorted data but achieves logarithmic performance.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Binary Search Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">BinarySearch</span> {
    
    <span class="comment">// Iterative Binary Search</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">binarySearch</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target) {
        <span class="type">int</span> left = <span class="number">0</span>;
        <span class="type">int</span> right = arr.length - <span class="number">1</span>;
        
        <span class="keyword">while</span> (left &lt;= right) {
            <span class="comment">// Avoid integer overflow</span>
            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;
            
            <span class="keyword">if</span> (arr[mid] == target) {
                <span class="keyword">return</span> mid;
            }
            
            <span class="keyword">if</span> (arr[mid] &lt; target) {
                left = mid + <span class="number">1</span>; <span class="comment">// Search right half</span>
            } <span class="keyword">else</span> {
                right = mid - <span class="number">1</span>; <span class="comment">// Search left half</span>
            }
        }
        
        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Target not found</span>
    }
    
    <span class="comment">// Recursive Binary Search</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">binarySearchRecursive</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target, <span class="type">int</span> left, <span class="type">int</span> right) {
        <span class="keyword">if</span> (left &lt;= right) {
            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;
            
            <span class="comment">// Found target</span>
            <span class="keyword">if</span> (arr[mid] == target) {
                <span class="keyword">return</span> mid;
            }
            
            <span class="comment">// Target is in left half</span>
            <span class="keyword">if</span> (arr[mid] &gt; target) {
                <span class="keyword">return</span> binarySearchRecursive(arr, target, left, mid - <span class="number">1</span>);
            }
            
            <span class="comment">// Target is in right half</span>
            <span class="keyword">return</span> binarySearchRecursive(arr, target, mid + <span class="number">1</span>, right);
        }
        
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
    
    <span class="comment">// Find first occurrence of target</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">findFirstOccurrence</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target) {
        <span class="type">int</span> left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>;
        <span class="type">int</span> result = -<span class="number">1</span>;
        
        <span class="keyword">while</span> (left &lt;= right) {
            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;
            
            <span class="keyword">if</span> (arr[mid] == target) {
                result = mid;
                right = mid - <span class="number">1</span>; <span class="comment">// Continue searching left</span>
            } <span class="keyword">else if</span> (arr[mid] &lt; target) {
                left = mid + <span class="number">1</span>;
            } <span class="keyword">else</span> {
                right = mid - <span class="number">1</span>;
            }
        }
        
        <span class="keyword">return</span> result;
    }
    
    <span class="comment">// Search in rotated sorted array</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">searchRotatedArray</span>(<span class="type">int</span>[] arr, <span class="type">int</span> target) {
        <span class="type">int</span> left = <span class="number">0</span>, right = arr.length - <span class="number">1</span>;
        
        <span class="keyword">while</span> (left &lt;= right) {
            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;
            
            <span class="keyword">if</span> (arr[mid] == target) {
                <span class="keyword">return</span> mid;
            }
            
            <span class="comment">// Left half is sorted</span>
            <span class="keyword">if</span> (arr[left] &lt;= arr[mid]) {
                <span class="keyword">if</span> (target &gt;= arr[left] && target &lt; arr[mid]) {
                    right = mid - <span class="number">1</span>;
                } <span class="keyword">else</span> {
                    left = mid + <span class="number">1</span>;
                }
            } 
            <span class="comment">// Right half is sorted</span>
            <span class="keyword">else</span> {
                <span class="keyword">if</span> (target &gt; arr[mid] && target &lt;= arr[right]) {
                    left = mid + <span class="number">1</span>;
                } <span class="keyword">else</span> {
                    right = mid - <span class="number">1</span>;
                }
            }
        }
        
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
}</code></pre>
            </div>

            <h2>📊 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>🎯 Practical Use Cases</h4>
                <ul>
                    <li><strong>Database Indexing:</strong> B-tree search for efficient record retrieval</li>
                    <li><strong>Web Search Engines:</strong> Inverted index searching for keyword matching</li>
                    <li><strong>File Systems:</strong> Directory traversal and file location</li>
                    <li><strong>Gaming:</strong> Collision detection and spatial partitioning</li>
                    <li><strong>Network Routing:</strong> Path finding in network topology</li>
                </ul>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Search Insert Position</a>
                    <a href="#" class="practice-link">Find First and Last Position</a>
                    <a href="#" class="practice-link">Search in Rotated Array</a>
                    <a href="#" class="practice-link">Find Peak Element</a>
                    <a href="#" class="practice-link">Search 2D Matrix</a>
                    <a href="#" class="practice-link">Find Minimum in Rotated Array</a>
                </div>
            </div>
        </div>

        <!-- Hash Tables -->
        <div class="content-section" id="hash-tables">
            <h1>🗂️ Hash Tables (Hashing)</h1>
            <p>
                Hash tables use hash functions to map keys to array indices, providing average O(1) time complexity for 
                insertion, deletion, and search operations. They're fundamental to many algorithms and data structures.
            </p>

            <div class="highlight-box">
                <h4>🎯 Hashing Core Concept</h4>
                <p>Transform keys into array indices using a hash function, then handle collisions when multiple keys map to the same index.</p>
            </div>

            <h2>📊 Hash Table Performance</h2>
            <div class="code-example">
                <div class="code-language">Performance Analysis</div>
                <pre><code><span class="comment">// Hash Table Operations Complexity</span>

<span class="keyword">Operation</span>     | <span class="keyword">Average Case</span> | <span class="keyword">Worst Case</span> | <span class="keyword">Best Case</span>
<span class="operator">-----------</span>+<span class="operator">--------------</span>+<span class="operator">-----------</span>+<span class="operator">----------</span>
Search        | O(<span class="number">1</span>)        | O(n)       | O(<span class="number">1</span>)
Insertion     | O(<span class="number">1</span>)        | O(n)       | O(<span class="number">1</span>)
Deletion      | O(<span class="number">1</span>)        | O(n)       | O(<span class="number">1</span>)

<span class="keyword">Collision Resolution Methods:</span>
• <span class="function">Chaining</span>: Store colliding elements in linked lists
• <span class="function">Open Addressing</span>: Find alternative slots within table
  - Linear Probing: h(k, i) = (h'(k) + i) mod m
  - Quadratic Probing: h(k, i) = (h'(k) + c₁i + c₂i²) mod m
  - Double Hashing: h(k, i) = (h₁(k) + i·h₂(k)) mod m

<span class="keyword">Load Factor</span> α = n/m (n = elements, m = table size)
• <span class="function">Optimal range</span>: α ≤ <span class="number">0.75</span> for good performance</• <span class="function">Dynamic resizing</span>: Resize when α exceeds threshold</code></pre>
            </div>

            <h2>🏗️ Hash Table Implementation</h2>
            <div class="highlight-box">
                <h4>🔧 Chaining Collision Resolution</h4>
                <p>Store multiple elements that hash to the same index in a linked list at that position. Simple and handles high load factors well.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Hash Table Implementation with Chaining</span>
<span class="keyword">import</span> java.util.*;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">HashTable</span>&lt;K, V&gt; {
    <span class="keyword">private</span> <span class="type">int</span> size;
    <span class="keyword">private</span> <span class="type">int</span> capacity;
    <span class="keyword">private</span> <span class="classname">LinkedList</span>&lt;<span class="classname">Entry</span>&gt;[] table;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> LOAD_FACTOR_THRESHOLD = <span class="number">0.75</span>;
    
    <span class="keyword">class</span> <span class="classname">Entry</span> {
        K key;
        V value;
        
        <span class="classname">Entry</span>(K key, V value) {
            <span class="keyword">this</span>.key = key;
            <span class="keyword">this</span>.value = value;
        }
    }
    
    <span class="keyword">public</span> <span class="classname">HashTable</span>() {
        <span class="keyword">this</span>(<span class="number">16</span>); <span class="comment">// Default capacity</span>
    }
    
    <span class="keyword">public</span> <span class="classname">HashTable</span>(<span class="type">int</span> capacity) {
        <span class="keyword">this</span>.capacity = capacity;
        <span class="keyword">this</span>.size = <span class="number">0</span>;
        table = <span class="keyword">new</span> <span class="classname">LinkedList</span>[capacity];
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) {
            table[i] = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
        }
    }
    
    <span class="comment">// Hash function using built-in hashCode()</span>
    <span class="keyword">private</span> <span class="type">int</span> <span class="function">hash</span>(K key) {
        <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;
        <span class="keyword">return</span> <span class="classname">Math</span>.abs(key.hashCode()) % capacity;
    }
    
    <span class="comment">// Insert or update key-value pair</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">put</span>(K key, V value) {
        <span class="type">int</span> index = hash(key);
        <span class="classname">LinkedList</span>&lt;<span class="classname">Entry</span>&gt; bucket = table[index];
        
        <span class="comment">// Update existing key</span>
        <span class="keyword">for</span> (<span class="classname">Entry</span> entry : bucket) {
            <span class="keyword">if</span> (entry.key != <span class="keyword">null</span> && entry.key.equals(key)) {
                entry.value = value;
                <span class="keyword">return</span>;
            }
        }
        
        <span class="comment">// Add new entry</span>
        bucket.add(<span class="keyword">new</span> <span class="classname">Entry</span>(key, value));
        size++;
        
        <span class="comment">// Check if resize is needed</span>
        <span class="keyword">if</span> ((<span class="type">double</span>) size / capacity &gt; LOAD_FACTOR_THRESHOLD) {
            resize();
        }
    }
    
    <span class="comment">// Retrieve value by key</span>
    <span class="keyword">public</span> V <span class="function">get</span>(K key) {
        <span class="type">int</span> index = hash(key);
        <span class="classname">LinkedList</span>&lt;<span class="classname">Entry</span>&gt; bucket = table[index];
        
        <span class="keyword">for</span> (<span class="classname">Entry</span> entry : bucket) {
            <span class="keyword">if</span> (entry.key != <span class="keyword">null</span> && entry.key.equals(key)) {
                <span class="keyword">return</span> entry.value;
            }
        }
        
        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Key not found</span>
    }
    
    <span class="comment">// Remove key-value pair</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">remove</span>(K key) {
        <span class="type">int</span> index = hash(key);
        <span class="classname">LinkedList</span>&lt;<span class="classname">Entry</span>&gt; bucket = table[index];
        
        <span class="type">boolean</span> removed = bucket.removeIf(entry -> 
            entry.key != <span class="keyword">null</span> && entry.key.equals(key));
        
        <span class="keyword">if</span> (removed) {
            size--;
        }
        
        <span class="keyword">return</span> removed;
    }
    
    <span class="comment">// Check if key exists</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">containsKey</span>(K key) {
        <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;
    }
    
    <span class="comment">// Dynamic resize when load factor exceeds threshold</span>
    <span class="keyword">private</span> <span class="type">void</span> <span class="function">resize</span>() {
        <span class="classname">LinkedList</span>&lt;<span class="classname">Entry</span>&gt;[] oldTable = table;
        <span class="type">int</span> oldCapacity = capacity;
        
        capacity *= <span class="number">2</span>;
        size = <span class="number">0</span>;
        table = <span class="keyword">new</span> <span class="classname">LinkedList</span>[capacity];
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) {
            table[i] = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
        }
        
        <span class="comment">// Rehash all existing entries</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; oldCapacity; i++) {
            <span class="keyword">for</span> (<span class="classname">Entry</span> entry : oldTable[i]) {
                put(entry.key, entry.value);
            }
        }
    }
    
    <span class="comment">// Get current size</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">size</span>() {
        <span class="keyword">return</span> size;
    }
    
    <span class="comment">// Check if empty</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> size == <span class="number">0</span>;
    }
}</code></pre>
            </div>

            <h2>🔧 Open Addressing Implementation</h2>
            <div class="highlight-box">
                <h4>🎯 Linear Probing Strategy</h4>
                <p>When a collision occurs, search linearly for the next available slot. Simple but can cause clustering problems.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Hash Table with Linear Probing</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">LinearProbingHashTable</span>&lt;K, V&gt; {
    <span class="keyword">private</span> K[] keys;
    <span class="keyword">private</span> V[] values;
    <span class="keyword">private</span> <span class="type">boolean</span>[] deleted; <span class="comment">// For lazy deletion</span>
    <span class="keyword">private</span> <span class="type">int</span> size;
    <span class="keyword">private</span> <span class="type">int</span> capacity;
    
    <span class="keyword">public</span> <span class="classname">LinearProbingHashTable</span>(<span class="type">int</span> capacity) {
        <span class="keyword">this</span>.capacity = capacity;
        <span class="keyword">this</span>.size = <span class="number">0</span>;
        keys = (K[]) <span class="keyword">new</span> <span class="classname">Object</span>[capacity];
        values = (V[]) <span class="keyword">new</span> <span class="classname">Object</span>[capacity];
        deleted = <span class="keyword">new</span> <span class="type">boolean</span>[capacity];
    }
    
    <span class="keyword">private</span> <span class="type">int</span> <span class="function">hash</span>(K key) {
        <span class="keyword">return</span> <span class="classname">Math</span>.abs(key.hashCode()) % capacity;
    }
    
    <span class="comment">// Find slot for key (for insertion or search)</span>
    <span class="keyword">private</span> <span class="type">int</span> <span class="function">findSlot</span>(K key, <span class="type">boolean</span> forInsertion) {
        <span class="type">int</span> index = hash(key);
        <span class="type">int</span> originalIndex = index;
        
        <span class="keyword">do</span> {
            <span class="keyword">if</span> (keys[index] == <span class="keyword">null</span> || 
                (forInsertion && deleted[index]) ||
                (keys[index] != <span class="keyword">null</span> && keys[index].equals(key))) {
                <span class="keyword">return</span> index;
            }
            
            index = (index + <span class="number">1</span>) % capacity; <span class="comment">// Linear probing</span>
        } <span class="keyword">while</span> (index != originalIndex);
        
        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Table full or not found</span>
    }
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">put</span>(K key, V value) {
        <span class="keyword">if</span> (size &gt;= capacity * <span class="number">0.75</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="classname">RuntimeException</span>(<span class="string">"Hash table is full"</span>);
        }
        
        <span class="type">int</span> index = findSlot(key, <span class="keyword">true</span>);
        <span class="keyword">if</span> (index == -<span class="number">1</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="classname">RuntimeException</span>(<span class="string">"Cannot insert - table full"</span>);
        }
        
        <span class="keyword">if</span> (keys[index] == <span class="keyword">null</span> || deleted[index]) {
            size++;
        }
        
        keys[index] = key;
        values[index] = value;
        deleted[index] = <span class="keyword">false</span>;
    }
    
    <span class="keyword">public</span> V <span class="function">get</span>(K key) {
        <span class="type">int</span> index = findSlot(key, <span class="keyword">false</span>);
        
        <span class="keyword">if</span> (index != -<span class="number">1</span> && keys[index] != <span class="keyword">null</span> && 
            !deleted[index] && keys[index].equals(key)) {
            <span class="keyword">return</span> values[index];
        }
        
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
    
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">remove</span>(K key) {
        <span class="type">int</span> index = findSlot(key, <span class="keyword">false</span>);
        
        <span class="keyword">if</span> (index != -<span class="number">1</span> && keys[index] != <span class="keyword">null</span> && 
            !deleted[index] && keys[index].equals(key)) {
            deleted[index] = <span class="keyword">true</span>; <span class="comment">// Lazy deletion</span>
            size--;
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}</code></pre>
            </div>

            <h2>🔐 Hash Function Design</h2>
            <div class="highlight-box">
                <h4>🎲 Good Hash Function Properties</h4>
                <ul>
                    <li><strong>Deterministic:</strong> Same input always produces same output</li>
                    <li><strong>Uniform Distribution:</strong> Keys distributed evenly across table</li>
                    <li><strong>Fast Computation:</strong> Hash function should be efficient to compute</li>
                    <li><strong>Avalanche Effect:</strong> Small input changes cause large output changes</li>
                </ul>
            </div>

            <h3>Example: Custom Hash Functions</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">HashFunctions</span> {
    
    <span class="comment">// Simple string hash (djb2 algorithm)</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="function">stringHash</span>(<span class="classname">String</span> str) {
        <span class="type">long</span> hash = <span class="number">5381</span>;
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) {
            hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + str.charAt(i);
        }
        <span class="keyword">return</span> <span class="classname">Math</span>.abs((<span class="type">int</span>) hash);
    }
    
    <span class="comment">// Polynomial rolling hash</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="function">polynomialHash</span>(<span class="classname">String</span> str, <span class="type">int</span> prime) {
        <span class="type">long</span> hash = <span class="number">0</span>;
        <span class="type">long</span> powerOfPrime = <span class="number">1</span>;
        
        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) {
            hash = (hash + (c - <span class="string">'a'</span> + <span class="number">1</span>) * powerOfPrime) % <span class="classname">Integer</span>.MAX_VALUE;
            powerOfPrime = (powerOfPrime * prime) % <span class="classname">Integer</span>.MAX_VALUE;
        }
        
        <span class="keyword">return</span> (<span class="type">int</span>) hash;
    }
    
    <span class="comment">// Universal hash function family</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="classname">UniversalHash</span> {
        <span class="keyword">private</span> <span class="type">int</span> a, b, p, m;
        <span class="keyword">private</span> <span class="classname">Random</span> random;
        
        <span class="keyword">public</span> <span class="classname">UniversalHash</span>(<span class="type">int</span> tableSize) {
            <span class="keyword">this</span>.m = tableSize;
            <span class="keyword">this</span>.p = <span class="number">982451653</span>; <span class="comment">// Large prime</span>
            <span class="keyword">this</span>.random = <span class="keyword">new</span> <span class="classname">Random</span>();
            generateParameters();
        }
        
        <span class="keyword">private</span> <span class="type">void</span> <span class="function">generateParameters</span>() {
            a = random.nextInt(p - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 1 <= a < p</span>
            b = random.nextInt(p);                      <span class="comment">// 0 <= b < p</span>
        }
        
        <span class="keyword">public</span> <span class="type">int</span> <span class="function">hash</span>(<span class="type">int</span> key) {
            <span class="keyword">return</span> <span class="classname">Math</span>.abs(((a * key + b) % p) % m);
        }
    }
    
    <span class="comment">// Consistent hashing (for distributed systems)</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="classname">ConsistentHash</span> {
        <span class="keyword">private</span> <span class="classname">TreeMap</span>&lt;<span class="classname">Integer</span>, <span class="classname">String</span>&gt; ring;
        <span class="keyword">private</span> <span class="type">int</span> virtualNodes;
        
        <span class="keyword">public</span> <span class="classname">ConsistentHash</span>(<span class="type">int</span> virtualNodes) {
            <span class="keyword">this</span>.virtualNodes = virtualNodes;
            <span class="keyword">this</span>.ring = <span class="keyword">new</span> <span class="classname">TreeMap</span>&lt;&gt;();
        }
        
        <span class="keyword">public</span> <span class="type">void</span> <span class="function">addNode</span>(<span class="classname">String</span> node) {
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; virtualNodes; i++) {
                <span class="type">int</span> hash = stringHash(node + i);
                ring.put(hash, node);
            }
        }
        
        <span class="keyword">public</span> <span class="classname">String</span> <span class="function">getNode</span>(<span class="classname">String</span> key) {
            <span class="keyword">if</span> (ring.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;
            
            <span class="type">int</span> hash = stringHash(key);
            <span class="classname">Integer</span> nodeKey = ring.ceilingKey(hash);
            
            <span class="keyword">if</span> (nodeKey == <span class="keyword">null</span>) {
                nodeKey = ring.firstKey(); <span class="comment">// Wrap around</span>
            }
            
            <span class="keyword">return</span> ring.get(nodeKey);
        }
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>🎯 Hash Table Use Cases</h4>
                <ul>
                    <li><strong>Database Indexing:</strong> Fast record lookup by primary key</li>
                    <li><strong>Caching Systems:</strong> LRU cache, Redis, Memcached</li>
                    <li><strong>Compilers:</strong> Symbol tables for variable names</li>
                    <li><strong>Network Routing:</strong> IP address to MAC address mapping</li>
                    <li><strong>Distributed Systems:</strong> Consistent hashing for load balancing</li>
                    <li><strong>Cryptography:</strong> Hash-based message authentication codes (HMAC)</li>
                </ul>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Two Sum</a>
                    <a href="#" class="practice-link">Group Anagrams</a>
                    <a href="#" class="practice-link">First Non-repeating Character</a>
                    <a href="#" class="practice-link">Design HashMap</a>
                    <a href="#" class="practice-link">LRU Cache</a>
                    <a href="#" class="practice-link">Valid Anagram</a>
                </div>
            </div>
        </div>

        <!-- Graphs -->
        <div class="content-section" id="graphs">
            <h1>🕸️ Graphs</h1>
            <p>
                Graphs are fundamental data structures consisting of vertices (nodes) connected by edges. They model relationships 
                and connections in networks, making them essential for algorithms in social networks, routing, and optimization.
            </p>

            <div class="highlight-box">
                <h4>🎯 Graph Theory Foundation</h4>
                <p>Graphs represent pairwise relationships between objects. Understanding different types and representations helps choose the right approach for specific problems.</p>
            </div>

            <h2>📊 Graph Classifications</h2>
            <div class="code-example">
                <div class="code-language">Graph Types Overview</div>
                <pre><code><span class="comment">// Graph Classification and Properties</span>

<span class="keyword">Graph Types:</span>
• <span class="function">Directed (Digraph)</span>: Edges have direction (A → B ≠ B → A)
• <span class="function">Undirected</span>: Edges have no direction (A — B = B — A)
• <span class="function">Weighted</span>: Edges have weights/costs
• <span class="function">Unweighted</span>: All edges have equal weight
• <span class="function">Connected</span>: Path exists between every pair of vertices
• <span class="function">Disconnected</span>: Some vertices not reachable from others

<span class="keyword">Graph Properties:</span>
• <span class="function">Vertices (V)</span>: Number of nodes
• <span class="function">Edges (E)</span>: Number of connections
• <span class="function">Degree</span>: Number of edges connected to a vertex
• <span class="function">Path</span>: Sequence of vertices connected by edges
• <span class="function">Cycle</span>: Path that starts and ends at same vertex

<span class="keyword">Representation Comparison:</span>
                    | <span class="keyword">Space</span>     | <span class="keyword">Edge Check</span> | <span class="keyword">Add Edge</span> | <span class="keyword">Neighbors</span>
<span class="operator">Adjacency Matrix</span>  | O(V²)    | O(<span class="number">1</span>)       | O(<span class="number">1</span>)      | O(V)
<span class="operator">Adjacency List</span>    | O(V + E) | O(degree)   | O(<span class="number">1</span>)      | O(degree)</code></pre>
            </div>

            <h2>🏗️ Graph Representations</h2>
            <div class="highlight-box">
                <h4>📋 Adjacency Matrix vs Adjacency List</h4>
                <p>Matrix representation uses O(V²) space but provides O(1) edge lookups. List representation uses O(V+E) space and is better for sparse graphs.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Graph Implementations</span>

<span class="comment">// 1. Adjacency Matrix Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">GraphMatrix</span> {
    <span class="keyword">private</span> <span class="type">int</span>[][] adjMatrix;
    <span class="keyword">private</span> <span class="type">int</span> numVertices;
    <span class="keyword">private</span> <span class="type">boolean</span> isDirected;
    
    <span class="keyword">public</span> <span class="classname">GraphMatrix</span>(<span class="type">int</span> numVertices, <span class="type">boolean</span> isDirected) {
        <span class="keyword">this</span>.numVertices = numVertices;
        <span class="keyword">this</span>.isDirected = isDirected;
        adjMatrix = <span class="keyword">new</span> <span class="type">int</span>[numVertices][numVertices];
    }
    
    <span class="comment">// Add edge with optional weight</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">addEdge</span>(<span class="type">int</span> src, <span class="type">int</span> dest, <span class="type">int</span> weight) {
        <span class="keyword">if</span> (src &gt;= <span class="number">0</span> && src &lt; numVertices && dest &gt;= <span class="number">0</span> && dest &lt; numVertices) {
            adjMatrix[src][dest] = weight;
            <span class="keyword">if</span> (!isDirected) {
                adjMatrix[dest][src] = weight;
            }
        }
    }
    
    <span class="comment">// Check if edge exists</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">hasEdge</span>(<span class="type">int</span> src, <span class="type">int</span> dest) {
        <span class="keyword">if</span> (src &gt;= <span class="number">0</span> && src &lt; numVertices && dest &gt;= <span class="number">0</span> && dest &lt; numVertices) {
            <span class="keyword">return</span> adjMatrix[src][dest] != <span class="number">0</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    
    <span class="comment">// Get edge weight</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">getWeight</span>(<span class="type">int</span> src, <span class="type">int</span> dest) {
        <span class="keyword">if</span> (hasEdge(src, dest)) {
            <span class="keyword">return</span> adjMatrix[src][dest];
        }
        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// No edge</span>
    }
    
    <span class="comment">// Get all neighbors of a vertex</span>
    <span class="keyword">public</span> <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; <span class="function">getNeighbors</span>(<span class="type">int</span> vertex) {
        <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; neighbors = <span class="keyword">new</span> <span class="classname">ArrayList</span>&lt;&gt;();
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++) {
            <span class="keyword">if</span> (adjMatrix[vertex][i] != <span class="number">0</span>) {
                neighbors.add(i);
            }
        }
        <span class="keyword">return</span> neighbors;
    }
    
    <span class="comment">// Print graph representation</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">printGraph</span>() {
        <span class="classname">System</span>.out.println(<span class="string">"Adjacency Matrix:"</span>);
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++) {
            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numVertices; j++) {
                <span class="classname">System</span>.out.print(adjMatrix[i][j] + <span class="string">" "</span>);
            }
            <span class="classname">System</span>.out.println();
        }
    }
}

<span class="comment">// 2. Adjacency List Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">GraphList</span> {
    <span class="keyword">private</span> <span class="type">int</span> vertices;
    <span class="keyword">private</span> <span class="classname">List</span>&lt;<span class="classname">List</span>&lt;<span class="classname">Edge</span>&gt;&gt; adjacencyList;
    <span class="keyword">private</span> <span class="type">boolean</span> isDirected;
    
    <span class="keyword">class</span> <span class="classname">Edge</span> {
        <span class="type">int</span> destination;
        <span class="type">int</span> weight;
        
        <span class="classname">Edge</span>(<span class="type">int</span> destination, <span class="type">int</span> weight) {
            <span class="keyword">this</span>.destination = destination;
            <span class="keyword">this</span>.weight = weight;
        }
    }
    
    <span class="keyword">public</span> <span class="classname">GraphList</span>(<span class="type">int</span> vertices, <span class="type">boolean</span> isDirected) {
        <span class="keyword">this</span>.vertices = vertices;
        <span class="keyword">this</span>.isDirected = isDirected;
        adjacencyList = <span class="keyword">new</span> <span class="classname">ArrayList</span>&lt;&gt;();
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertices; i++) {
            adjacencyList.add(<span class="keyword">new</span> <span class="classname">ArrayList</span>&lt;&gt;());
        }
    }
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">addEdge</span>(<span class="type">int</span> src, <span class="type">int</span> dest, <span class="type">int</span> weight) {
        adjacencyList.get(src).add(<span class="keyword">new</span> <span class="classname">Edge</span>(dest, weight));
        <span class="keyword">if</span> (!isDirected) {
            adjacencyList.get(dest).add(<span class="keyword">new</span> <span class="classname">Edge</span>(src, weight));
        }
    }
    
    <span class="keyword">public</span> <span class="classname">List</span>&lt;<span class="classname">Edge</span>&gt; <span class="function">getNeighbors</span>(<span class="type">int</span> vertex) {
        <span class="keyword">return</span> adjacencyList.get(vertex);
    }
}</code></pre>
            </div>

            <h2>🔍 Breadth-First Search (BFS)</h2>
            <div class="highlight-box">
                <h4>🌊 Level-by-Level Exploration</h4>
                <p>BFS explores vertices level by level using a queue. Perfect for finding shortest paths in unweighted graphs and exploring immediate neighbors first.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// BFS Implementation with Multiple Applications</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">BreadthFirstSearch</span> {
    
    <span class="comment">// Basic BFS traversal</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">BFS</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> startVertex) {
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="classname">Queue</span>&lt;<span class="classname">Integer</span>&gt; queue = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
        
        visited[startVertex] = <span class="keyword">true</span>;
        queue.offer(startVertex);
        
        <span class="classname">System</span>.out.print(<span class="string">"BFS Traversal: "</span>);
        
        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> vertex = queue.poll();
            <span class="classname">System</span>.out.print(vertex + <span class="string">" "</span>);
            
            <span class="comment">// Visit all unvisited neighbors</span>
            <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(vertex)) {
                <span class="keyword">if</span> (!visited[edge.destination]) {
                    visited[edge.destination] = <span class="keyword">true</span>;
                    queue.offer(edge.destination);
                }
            }
        }
        <span class="classname">System</span>.out.println();
    }
    
    <span class="comment">// BFS for shortest path in unweighted graph</span>
    <span class="keyword">public</span> <span class="type">int</span>[] <span class="function">shortestPath</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> source) {
        <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="type">int</span>[graph.vertices];
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="classname">Queue</span>&lt;<span class="classname">Integer</span>&gt; queue = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
        
        <span class="classname">Arrays</span>.fill(distance, -<span class="number">1</span>);
        distance[source] = <span class="number">0</span>;
        visited[source] = <span class="keyword">true</span>;
        queue.offer(source);
        
        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> vertex = queue.poll();
            
            <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(vertex)) {
                <span class="keyword">if</span> (!visited[edge.destination]) {
                    visited[edge.destination] = <span class="keyword">true</span>;
                    distance[edge.destination] = distance[vertex] + <span class="number">1</span>;
                    queue.offer(edge.destination);
                }
            }
        }
        
        <span class="keyword">return</span> distance;
    }
    
    <span class="comment">// Check if graph is connected</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">isConnected</span>(<span class="classname">GraphList</span> graph) {
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="classname">Queue</span>&lt;<span class="classname">Integer</span>&gt; queue = <span class="keyword">new</span> <span class="classname">LinkedList</span>&lt;&gt;();
        
        queue.offer(<span class="number">0</span>);
        visited[<span class="number">0</span>] = <span class="keyword">true</span>;
        <span class="type">int</span> visitedCount = <span class="number">1</span>;
        
        <span class="keyword">while</span> (!queue.isEmpty()) {
            <span class="type">int</span> vertex = queue.poll();
            
            <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(vertex)) {
                <span class="keyword">if</span> (!visited[edge.destination]) {
                    visited[edge.destination] = <span class="keyword">true</span>;
                    visitedCount++;
                    queue.offer(edge.destination);
                }
            }
        }
        
        <span class="keyword">return</span> visitedCount == graph.vertices;
    }
}</code></pre>
            </div>

            <h2>🏃 Depth-First Search (DFS)</h2>
            <div class="highlight-box">
                <h4>🌳 Deep Exploration Strategy</h4>
                <p>DFS explores as far as possible along each branch before backtracking. Excellent for detecting cycles, topological sorting, and finding connected components.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// DFS Implementation with Applications</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">DepthFirstSearch</span> {
    
    <span class="comment">// Recursive DFS traversal</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">DFS</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> vertex, <span class="type">boolean</span>[] visited) {
        visited[vertex] = <span class="keyword">true</span>;
        <span class="classname">System</span>.out.print(vertex + <span class="string">" "</span>);
        
        <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(vertex)) {
            <span class="keyword">if</span> (!visited[edge.destination]) {
                DFS(graph, edge.destination, visited);
            }
        }
    }
    
    <span class="comment">// Iterative DFS using Stack</span>
    <span class="keyword">public</span> <span class="type">void</span> <span class="function">DFSIterative</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> startVertex) {
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="classname">Stack</span>&lt;<span class="classname">Integer</span>&gt; stack = <span class="keyword">new</span> <span class="classname">Stack</span>&lt;&gt;();
        
        stack.push(startVertex);
        
        <span class="classname">System</span>.out.print(<span class="string">"DFS Traversal: "</span>);
        
        <span class="keyword">while</span> (!stack.isEmpty()) {
            <span class="type">int</span> vertex = stack.pop();
            
            <span class="keyword">if</span> (!visited[vertex]) {
                visited[vertex] = <span class="keyword">true</span>;
                <span class="classname">System</span>.out.print(vertex + <span class="string">" "</span>);
                
                <span class="comment">// Add neighbors to stack (reverse order for consistent traversal)</span>
                <span class="classname">List</span>&lt;<span class="classname">GraphList</span>.<span class="classname">Edge</span>&gt; neighbors = graph.getNeighbors(vertex);
                <span class="keyword">for</span> (<span class="type">int</span> i = neighbors.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
                    <span class="type">int</span> neighbor = neighbors.get(i).destination;
                    <span class="keyword">if</span> (!visited[neighbor]) {
                        stack.push(neighbor);
                    }
                }
            }
        }
        <span class="classname">System</span>.out.println();
    }
    
    <span class="comment">// Detect cycle in directed graph</span>
    <span class="keyword">public</span> <span class="type">boolean</span> <span class="function">hasCycle</span>(<span class="classname">GraphList</span> graph) {
        <span class="type">int</span>[] color = <span class="keyword">new</span> <span class="type">int</span>[graph.vertices]; <span class="comment">// 0: White, 1: Gray, 2: Black</span>
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vertices; i++) {
            <span class="keyword">if</span> (color[i] == <span class="number">0</span> && hasCycleDFS(graph, i, color)) {
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    
    <span class="keyword">private</span> <span class="type">boolean</span> <span class="function">hasCycleDFS</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> vertex, <span class="type">int</span>[] color) {
        color[vertex] = <span class="number">1</span>; <span class="comment">// Mark as gray (visiting)</span>
        
        <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(vertex)) {
            <span class="keyword">if</span> (color[edge.destination] == <span class="number">1</span>) {
                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Back edge found - cycle detected</span>
            }
            <span class="keyword">if</span> (color[edge.destination] == <span class="number">0</span> && hasCycleDFS(graph, edge.destination, color)) {
                <span class="keyword">return</span> <span class="keyword">true</span>;
            }
        }
        
        color[vertex] = <span class="number">2</span>; <span class="comment">// Mark as black (processed)</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
    
    <span class="comment">// Find connected components</span>
    <span class="keyword">public</span> <span class="type">int</span> <span class="function">countConnectedComponents</span>(<span class="classname">GraphList</span> graph) {
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="type">int</span> components = <span class="number">0</span>;
        
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.vertices; i++) {
            <span class="keyword">if</span> (!visited[i]) {
                DFS(graph, i, visited);
                components++;
            }
        }
        
        <span class="keyword">return</span> components;
    }
}</code></pre>
            </div>

            <h2>🛣️ Dijkstra's Shortest Path Algorithm</h2>
            <div class="highlight-box">
                <h4>🎯 Weighted Graph Navigation</h4>
                <p>Dijkstra's algorithm finds shortest paths from a source vertex to all other vertices in weighted graphs with non-negative weights.</p>
            </div>

            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="comment">// Dijkstra's Algorithm Implementation</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">DijkstraAlgorithm</span> {
    
    <span class="keyword">class</span> <span class="classname">Node</span> <span class="keyword">implements</span> <span class="classname">Comparable</span>&lt;<span class="classname">Node</span>&gt; {
        <span class="type">int</span> vertex;
        <span class="type">int</span> distance;
        
        <span class="classname">Node</span>(<span class="type">int</span> vertex, <span class="type">int</span> distance) {
            <span class="keyword">this</span>.vertex = vertex;
            <span class="keyword">this</span>.distance = distance;
        }
        
        <span class="keyword">public</span> <span class="type">int</span> <span class="function">compareTo</span>(<span class="classname">Node</span> other) {
            <span class="keyword">return</span> <span class="classname">Integer</span>.compare(<span class="keyword">this</span>.distance, other.distance);
        }
    }
    
    <span class="keyword">public</span> <span class="type">int</span>[] <span class="function">dijkstra</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> source) {
        <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="type">int</span>[graph.vertices];
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="classname">PriorityQueue</span>&lt;<span class="classname">Node</span>&gt; pq = <span class="keyword">new</span> <span class="classname">PriorityQueue</span>&lt;&gt;();
        
        <span class="comment">// Initialize distances to infinity</span>
        <span class="classname">Arrays</span>.fill(distance, <span class="classname">Integer</span>.MAX_VALUE);
        distance[source] = <span class="number">0</span>;
        pq.offer(<span class="keyword">new</span> <span class="classname">Node</span>(source, <span class="number">0</span>));
        
        <span class="keyword">while</span> (!pq.isEmpty()) {
            <span class="classname">Node</span> current = pq.poll();
            <span class="type">int</span> u = current.vertex;
            
            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;
            visited[u] = <span class="keyword">true</span>;
            
            <span class="comment">// Relax all neighbors</span>
            <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(u)) {
                <span class="type">int</span> v = edge.destination;
                <span class="type">int</span> weight = edge.weight;
                
                <span class="keyword">if</span> (!visited[v] && distance[u] + weight &lt; distance[v]) {
                    distance[v] = distance[u] + weight;
                    pq.offer(<span class="keyword">new</span> <span class="classname">Node</span>(v, distance[v]));
                }
            }
        }
        
        <span class="keyword">return</span> distance;
    }
    
    <span class="comment">// Find shortest path with path reconstruction</span>
    <span class="keyword">public</span> <span class="classname">PathResult</span> <span class="function">shortestPathWithPath</span>(<span class="classname">GraphList</span> graph, <span class="type">int</span> source, <span class="type">int</span> target) {
        <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="type">int</span>[graph.vertices];
        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="type">int</span>[graph.vertices];
        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="type">boolean</span>[graph.vertices];
        <span class="classname">PriorityQueue</span>&lt;<span class="classname">Node</span>&gt; pq = <span class="keyword">new</span> <span class="classname">PriorityQueue</span>&lt;&gt;();
        
        <span class="classname">Arrays</span>.fill(distance, <span class="classname">Integer</span>.MAX_VALUE);
        <span class="classname">Arrays</span>.fill(parent, -<span class="number">1</span>);
        
        distance[source] = <span class="number">0</span>;
        pq.offer(<span class="keyword">new</span> <span class="classname">Node</span>(source, <span class="number">0</span>));
        
        <span class="keyword">while</span> (!pq.isEmpty()) {
            <span class="classname">Node</span> current = pq.poll();
            <span class="type">int</span> u = current.vertex;
            
            <span class="keyword">if</span> (u == target) <span class="keyword">break</span>; <span class="comment">// Early termination</span>
            <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;
            
            visited[u] = <span class="keyword">true</span>;
            
            <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : graph.getNeighbors(u)) {
                <span class="type">int</span> v = edge.destination;
                <span class="type">int</span> weight = edge.weight;
                
                <span class="keyword">if</span> (!visited[v] && distance[u] + weight &lt; distance[v]) {
                    distance[v] = distance[u] + weight;
                    parent[v] = u;
                    pq.offer(<span class="keyword">new</span> <span class="classname">Node</span>(v, distance[v]));
                }
            }
        }
        
        <span class="comment">// Reconstruct path</span>
        <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; path = reconstructPath(parent, source, target);
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="classname">PathResult</span>(distance[target], path);
    }
    
    <span class="keyword">private</span> <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; <span class="function">reconstructPath</span>(<span class="type">int</span>[] parent, <span class="type">int</span> source, <span class="type">int</span> target) {
        <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; path = <span class="keyword">new</span> <span class="classname">ArrayList</span>&lt;&gt;();
        <span class="type">int</span> current = target;
        
        <span class="keyword">while</span> (current != -<span class="number">1</span>) {
            path.add(current);
            current = parent[current];
        }
        
        <span class="classname">Collections</span>.reverse(path);
        <span class="keyword">return</span> path.get(<span class="number">0</span>) == source ? path : <span class="keyword">new</span> <span class="classname">ArrayList</span>&lt;&gt;();
    }
    
    <span class="keyword">class</span> <span class="classname">PathResult</span> {
        <span class="type">int</span> distance;
        <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; path;
        
        <span class="classname">PathResult</span>(<span class="type">int</span> distance, <span class="classname">List</span>&lt;<span class="classname">Integer</span>&gt; path) {
            <span class="keyword">this</span>.distance = distance;
            <span class="keyword">this</span>.path = path;
        }
    }
}</code></pre>
            </div>

            <h2>🚀 Real-World Applications</h2>
            <div class="highlight-box">
                <h4>🌍 Graph Applications in Practice</h4>
                <ul>
                    <li><strong>Social Networks:</strong> Friend recommendations, influence propagation</li>
                    <li><strong>GPS Navigation:</strong> Shortest route calculation, traffic optimization</li>
                    <li><strong>Network Routing:</strong> Internet packet routing, network topology</li>
                    <li><strong>Web Search:</strong> PageRank algorithm, web crawling</li>
                    <li><strong>Dependency Resolution:</strong> Build systems, package managers</li>
                    <li><strong>Game Development:</strong> Pathfinding AI, decision trees</li>
                    <li><strong>Bioinformatics:</strong> Gene networks, protein interactions</li>
                </ul>
            </div>

            <h3>Example: Social Network Analysis</h3>
            <div class="code-example">
                <div class="code-language">Java</div>
                <pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="classname">SocialNetworkAnalyzer</span> {
    
    <span class="comment">// Find mutual friends between two users</span>
    <span class="keyword">public</span> <span class="classname">Set</span>&lt;<span class="classname">Integer</span>&gt; <span class="function">findMutualFriends</span>(<span class="classname">GraphList</span> network, <span class="type">int</span> user1, <span class="type">int</span> user2) {
        <span class="classname">Set</span>&lt;<span class="classname">Integer</span>&gt; friends1 = <span class="keyword">new</span> <span class="classname">HashSet</span>&lt;&gt;();
        <span class="classname">Set</span>&lt;<span class="classname">Integer</span>&gt; friends2 = <span class="keyword">new</span> <span class="classname">HashSet</span>&lt;&gt;();
        
        <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : network.getNeighbors(user1)) {
            friends1.add(edge.destination);
        }
        
        <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : network.getNeighbors(user2)) {
            friends2.add(edge.destination);
        }
        
        friends1.retainAll(friends2); <span class="comment">// Intersection</span>
        <span class="keyword">return</span> friends1;
    }
    
    <span class="comment">// Calculate influence score (simplified PageRank)</span>
    <span class="keyword">public</span> <span class="type">double</span>[] <span class="function">calculateInfluence</span>(<span class="classname">GraphList</span> network, <span class="type">double</span> dampingFactor) {
        <span class="type">int</span> n = network.vertices;
        <span class="type">double</span>[] influence = <span class="keyword">new</span> <span class="type">double</span>[n];
        <span class="type">double</span>[] newInfluence = <span class="keyword">new</span> <span class="type">double</span>[n];
        
        <span class="comment">// Initialize with equal influence</span>
        <span class="classname">Arrays</span>.fill(influence, <span class="number">1.0</span> / n);
        
        <span class="comment">// Iterate until convergence</span>
        <span class="keyword">for</span> (<span class="type">int</span> iteration = <span class="number">0</span>; iteration &lt; <span class="number">100</span>; iteration++) {
            <span class="classname">Arrays</span>.fill(newInfluence, (<span class="number">1.0</span> - dampingFactor) / n);
            
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
                <span class="type">int</span> outDegree = network.getNeighbors(i).size();
                <span class="keyword">if</span> (outDegree &gt; <span class="number">0</span>) {
                    <span class="type">double</span> contribution = dampingFactor * influence[i] / outDegree;
                    <span class="keyword">for</span> (<span class="classname">GraphList</span>.<span class="classname">Edge</span> edge : network.getNeighbors(i)) {
                        newInfluence[edge.destination] += contribution;
                    }
                }
            }
            
            influence = newInfluence.clone();
        }
        
        <span class="keyword">return</span> influence;
    }
}</code></pre>
            </div>

            <div class="practice-section">
                <h4>🏋️ Practice Problems</h4>
                <div class="practice-links">
                    <a href="#" class="practice-link">Number of Islands</a>
                    <a href="#" class="practice-link">Course Schedule</a>
                    <a href="#" class="practice-link">Network Delay Time</a>
                    <a href="#" class="practice-link">Clone Graph</a>
                    <a href="#" class="practice-link">Word Ladder</a>
                    <a href="#" class="practice-link">Minimum Spanning Tree</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ------------------ Custom Video Player Initialization ------------------ */
        (function() {
            function formatTime(seconds) {
                if (isNaN(seconds)) return '00:00';
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                return (hrs ? String(hrs).padStart(2,'0') + ':' : '') +
                    String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0');
            }

            function createPlayer(video) {
                const wrapper = document.createElement('div');
                wrapper.className = 'player paused';

                // Move video into wrapper
                const parent = video.parentNode;
                parent.replaceChild(wrapper, video);
                wrapper.appendChild(video);

                // Disable native browser controls to avoid duplicate UI
                try {
                    video.removeAttribute('controls');
                    video.controls = false;
                } catch (e) {}
                // allow inline playback on mobile
                try { video.setAttribute('playsinline', ''); video.setAttribute('webkit-playsinline', ''); } catch (e) {}

                // Big play button
                const bigPlay = document.createElement('button');
                bigPlay.className = 'big-play';
                bigPlay.innerHTML = '►';
                wrapper.appendChild(bigPlay);

                // Controls container
                const controls = document.createElement('div');
                controls.className = 'controls';

                // Play/Pause
                const playBtn = document.createElement('button');
                playBtn.className = 'control-btn play';
                playBtn.innerHTML = 'Play';
                controls.appendChild(playBtn);

                // Progress (with knob)
                const progress = document.createElement('div');
                progress.className = 'progress';
                progress.style.flex = '1';
                const buffer = document.createElement('div'); buffer.className = 'buffer';
                const bar = document.createElement('div'); bar.className = 'bar';
                const knob = document.createElement('div'); knob.className = 'knob';
                progress.appendChild(buffer); progress.appendChild(bar); progress.appendChild(knob);
                controls.appendChild(progress);

                // Time
                const time = document.createElement('div');
                time.className = 'time';
                time.textContent = '00:00 / 00:00';
                controls.appendChild(time);

                // Volume
                const vol = document.createElement('input');
                vol.type = 'range'; vol.min = 0; vol.max = 1; vol.step = 0.01; vol.value = video.volume;
                vol.className = 'volume';
                controls.appendChild(vol);

                // Speed
                const rate = document.createElement('select');
                rate.className = 'playback-rate';
                [0.5,0.75,1,1.25,1.5,1.75,2].forEach(r => {
                    const o = document.createElement('option'); o.value = r; o.text = r + 'x';
                    if (r === 1) o.selected = true;
                    rate.appendChild(o);
                });
                controls.appendChild(rate);

                // Fullscreen
                const fs = document.createElement('button'); fs.className = 'control-btn fs'; fs.textContent = '⤢';
                controls.appendChild(fs);

                // Download
                const src = video.querySelector('source')?.src || video.currentSrc || '';
                const dl = document.createElement('a'); dl.className = 'download-link'; dl.href = src; dl.download = ''; dl.textContent = '⤓';
                controls.appendChild(dl);

                wrapper.appendChild(controls);

                // Events
                function updateUI() {
                    const pct = (video.currentTime / Math.max(video.duration || 1, 1));
                    bar.style.width = (pct * 100) + '%';
                    // position knob
                    const rect = progress.getBoundingClientRect();
                    const knobX = (rect.width * pct);
                    knob.style.left = (knobX) + 'px';
                    time.textContent = formatTime(video.currentTime) + ' / ' + (isFinite(video.duration) ? formatTime(video.duration) : '00:00');
                }

                video.addEventListener('timeupdate', updateUI);
                video.addEventListener('durationchange', updateUI);
                video.addEventListener('progress', function() {
                    try {
                        const buffered = video.buffered;
                        if (buffered.length) {
                            const end = buffered.end(buffered.length - 1);
                            buffer.style.width = (end / Math.max(video.duration || 1, 1) * 100) + '%';
                        }
                    } catch (e) {}
                });

                function setPlayingState(playing) {
                    if (playing) {
                        wrapper.classList.remove('paused');
                        playBtn.textContent = 'Pause';
                        bigPlay.style.opacity = 0;
                    } else {
                        wrapper.classList.add('paused');
                        playBtn.textContent = 'Play';
                        bigPlay.style.opacity = 1;
                    }
                }

                playBtn.addEventListener('click', function() {
                    if (video.paused) video.play(); else video.pause();
                });

                bigPlay.addEventListener('click', function() { if (video.paused) video.play(); else video.pause(); });

                // Click on video area toggles play/pause (like YouTube).
                // Ignore clicks that originate from the control bar so interacting with controls doesn't toggle playback.
                video.addEventListener('click', function(e) {
                    // If user clicked on controls (or their children), don't toggle
                    if (e.target.closest && e.target.closest('.controls')) return;
                    // If currently dragging the progress, don't toggle
                    if (typeof dragging !== 'undefined' && dragging) return;
                    if (video.paused) video.play(); else video.pause();
                });

                video.addEventListener('play', function() { setPlayingState(true); });
                video.addEventListener('pause', function() { setPlayingState(false); });

                // Seek on progress click
                progress.addEventListener('click', function(e) {
                    const rect = progress.getBoundingClientRect();
                    const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                    video.currentTime = pct * (video.duration || 0);
                });

                // Dragging
                let dragging = false;
                progress.addEventListener('mousedown', function(e) { dragging = true; });
                window.addEventListener('mouseup', function(e) { if (dragging) dragging = false; });
                window.addEventListener('mousemove', function(e) { if (!dragging) return; const rect = progress.getBoundingClientRect(); const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)); video.currentTime = pct * (video.duration || 0); });

                // Volume
                vol.addEventListener('input', function() { video.volume = parseFloat(vol.value); });

                // Playback rate
                rate.addEventListener('change', function() { video.playbackRate = parseFloat(rate.value); });

                // Fullscreen
                fs.addEventListener('click', function() {
                    const isFs = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
                    if (!isFs) {
                        // request fullscreen with vendor fallbacks
                        if (wrapper.requestFullscreen) wrapper.requestFullscreen();
                        else if (wrapper.webkitRequestFullscreen) wrapper.webkitRequestFullscreen();
                        else if (wrapper.mozRequestFullScreen) wrapper.mozRequestFullScreen();
                        else if (wrapper.msRequestFullscreen) wrapper.msRequestFullscreen();
                        wrapper.classList.add('is-fullscreen');
                    } else {
                        if (document.exitFullscreen) document.exitFullscreen();
                        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                        else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                        else if (document.msExitFullscreen) document.msExitFullscreen();
                        wrapper.classList.remove('is-fullscreen');
                    }
                });

                // Listen for fullscreen change events to ensure class sync
                ['fullscreenchange','webkitfullscreenchange','mozfullscreenchange','MSFullscreenChange'].forEach(evt => {
                    document.addEventListener(evt, function() {
                        const isFs = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
                        if (!isFs) wrapper.classList.remove('is-fullscreen');
                        else wrapper.classList.add('is-fullscreen');
                    });
                });

                // Update download link if source changes
                const updateDownloadHref = () => {
                    const s = video.querySelector('source')?.src || video.currentSrc || '';
                    dl.href = s;
                };
                updateDownloadHref();

                // Make keyboard accessible: Space toggles play when focused
                wrapper.tabIndex = 0;
                wrapper.addEventListener('keydown', function(e) {
                    if (e.code === 'Space') { e.preventDefault(); if (video.paused) video.play(); else video.pause(); }
                });

                // Initial UI state
                setPlayingState(video.paused);
                updateUI();
            }

            // Replace plain video tags with custom player wrappers
            document.addEventListener('DOMContentLoaded', function() {
                const videos = Array.from(document.querySelectorAll('.video-section video'));
                videos.forEach(v => {
                    try { createPlayer(v); } catch (e) { console.error('Failed to enhance video player', e); }
                });
            });
        })();

        function toggleContent(topicId) {
            const content = document.getElementById(topicId + '-content');
            const button = document.getElementById(topicId + '-btn');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                button.textContent = '▼';
                button.classList.remove('rotated');
            } else {
                content.style.display = 'none';
                button.textContent = '▶';
                button.classList.add('rotated');
            }
        }
        
        // Initialize all content as visible
        document.addEventListener('DOMContentLoaded', function() {
            const contents = document.querySelectorAll('.topic-content');
            contents.forEach(content => {
                content.style.display = 'block';
            });
        });
        
        // Enhanced Table of Contents functionality
        function toggleTOC() {
            const tocContainer = document.getElementById('tocContainer');
            const tocBackdrop = document.getElementById('tocBackdrop');
            const isActive = tocContainer.classList.contains('active');
            
            if (isActive) {
                tocContainer.classList.remove('active');
                tocBackdrop.classList.remove('active');
            } else {
                tocContainer.classList.add('active');
                tocBackdrop.classList.add('active');
            }
        }

        // Close TOC when clicking on backdrop
        document.addEventListener('DOMContentLoaded', function() {
            const tocBackdrop = document.getElementById('tocBackdrop');
            const tocContainer = document.getElementById('tocContainer');
            
            tocBackdrop.addEventListener('click', function() {
                tocContainer.classList.remove('active');
                tocBackdrop.classList.remove('active');
            });
        });
        
        // Back to top functionality
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.getElementById('backToTop');
            if (window.pageYOffset > 300) {
                backToTop.classList.add('visible');
            } else {
                backToTop.classList.remove('visible');
            }
        });
        
        // Close TOC when clicking on a link
        document.addEventListener('DOMContentLoaded', function() {
            const tocLinks = document.querySelectorAll('.toc-list a');
            tocLinks.forEach(link => {
                link.addEventListener('click', function() {
                    const tocContainer = document.getElementById('tocContainer');
                    const tocBackdrop = document.getElementById('tocBackdrop');
                    tocContainer.classList.remove('active');
                    tocBackdrop.classList.remove('active');
                });
            });
        });
        
        // Close TOC when clicking outside
        document.addEventListener('click', function(event) {
            const tocContainer = document.getElementById('tocContainer');
            const tocBackdrop = document.getElementById('tocBackdrop');
            const tocToggle = document.querySelector('.toc-toggle');
            
            if (!tocContainer.contains(event.target) && 
                !tocToggle.contains(event.target) && 
                !tocBackdrop.contains(event.target)) {
                tocContainer.classList.remove('active');
                tocBackdrop.classList.remove('active');
            }
        });
        
        // Video error handling
        document.addEventListener('DOMContentLoaded', function() {
            const videos = document.querySelectorAll('video');
            videos.forEach(video => {
                video.addEventListener('error', function(e) {
                    console.log('Video loading error:', e);
                    const videoSection = video.closest('.video-section');
                    const source = video.querySelector('source');
                    const videoPath = source?.src || 'Unknown';
                    
                    if (videoSection) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'video-error';
                        errorDiv.style.cssText = `
                            background: linear-gradient(45deg, #e74c3c, #c0392b);
                            color: white;
                            padding: 40px 20px;
                            text-align: center;
                            border-radius: 12px;
                            margin: 20px 0;
                            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
                        `;
                        
                        // Extract just the filename from the path
                        const filename = videoPath.split('/').pop();
                        
                        errorDiv.innerHTML = `
                            <h4>📹 Video Not Found</h4>
                            <p>The video file could not be loaded.</p>
                            <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                                <strong>File:</strong> ${filename}<br>
                                <strong>Path:</strong> <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; font-size: 0.9em;">${videoPath}</code>
                            </div>
                            <p style="font-size: 0.9em; margin-top: 15px;">
                                💡 <strong>Tip:</strong> Try opening the file directly from the file explorer:<br>
                                <code style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; display: inline-block; margin-top: 5px;">
                                    ${videoPath.replace('../', 'e:\\Materials\\Skills\\ITI\\summary\\')}
                                </code>
                            </p>
                        `;
                        
                        video.style.display = 'none';
                        videoSection.appendChild(errorDiv);
                    }
                });
                
                video.addEventListener('loadstart', function() {
                    console.log('Video loading started:', video.querySelector('source')?.src);
                });
                
                video.addEventListener('canplay', function() {
                    console.log('Video ready to play:', video.querySelector('source')?.src);
                });
            });
        });
    </script>
</body>
</html>
