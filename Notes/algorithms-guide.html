<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algorithms Study Guide - Complete Course</title>
  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="../assets/css/main.css" />
</head>
<body>
  <!-- Table of Contents Toggle Button -->
  <button class="toc-toggle" onclick="toggleTOC()"><i class="fas fa-bars"></i></button>
  <!-- Table of Contents -->
  <div class="toc-container" id="tocContainer">
    <div class="toc-header">
      <h3><i class="fas fa-books"></i> Algorithm Study Guide</h3>
    </div>
    <div class="toc-list">
      <ul>
        <li><a href="#lecture1"><i class="fas fa-chart-bar"></i> Analysis & Sorting</a></li>
        <li><a href="#lecture2"><i class="fas fa-bullseye"></i> Asymptotic Notation</a></li>
        <li><a href="#lecture3"><i class="fas fa-search"></i> Order Statistics</a></li>
        <li><a href="#lecture4">#<i class="fas fa-star"></i> Hashing</a></li>
        <li><a href="#lecture5"><i class="fas fa-star"></i> Linear Sorting</a></li>
        <li><a href="#lecture10"><i class="fas fa-star"></i> Dynamic Programming</a></li>
        <li><a href="#lecture13"><i class="fas fa-bullseye"></i> Greedy Algorithms</a></li>
        <li><a href="#lecture15"><i class="fas fa-globe"></i> Graph Algorithms</a></li>
        <li><a href="#lecture18"><i class="fas fa-link"></i> Advanced Graphs</a></li>
      </ul>
    </div>
  </div>
  <!-- Back to Top Button -->
  <button class="back-to-top" id="backToTop" onclick="scrollToTop()">?</button>
  <div class="container">
    <a href="../index.html" class="back-button"><i class="fas fa-arrow-left"></i> Back to Main Page</a><div class="header">
      <h1><i class="fas fa-chart-bar"></i> Algorithms Study Guide</h1>
      <p>Complete Course on Algorithm Analysis and Design</p>
    </div>
    <div class="nav-links">
      <a href="../index.html">? Back to Main Page</a>
    </div>
    <!-- Analysis & Sorting -->
    <div class="topic-section" id="lecture1">
      <div class="topic-header">
        <h2><i class="fas fa-chart-bar"></i> Analysis of Algorithms & Sorting</h2>
        <div class="difficulty beginner">Beginner</div>
      </div>
      <div class="topic-content">
        <div class="subtopic">
          <h3><i class="fas fa-bullseye"></i> What is Algorithm Analysis?</h3>
          <p>Algorithm analysis is the theoretical study of a computer program's performance and resource usage.
            While performance is important, other factors like correctness, simplicity, and reliability are also
            critical.</p>
          <p>Studying algorithms helps us understand <strong>scalability</strong>, and performance often
            distinguishes between what's feasible and what's impossible.</p>
          <div class="code-example">
            // Time Complexity Examples
            // O(1) - Constant Time
            <span class="function">getFirstElement</span>(<span class="type">int</span>[] arr) {
            <span class="keyword">return</span> arr[<span class="number">0</span>];
            }
            // O(n) - Linear Time
            <span class="type">int</span> <span class="function">findMax</span>(<span class="type">int</span>[] arr) {
            <span class="type">int</span> max = arr[<span class="number">0</span>];
            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i <
              arr.length; i++) { <span class="keyword">if</span>(arr[i] > max) max = arr[i];
              }
              <span class="keyword">return</span> max;
              }
              // O(n�) - Quadratic Time
              <span class="keyword">void</span> <span class="function">bubbleSort</span>(<span class="type">int</span>[]
              arr) {
              <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i <
                arr.length; i++) { <span class="keyword">for</span>(<span class="type">int</span> j = <span
                  class="number">0</span>; j < arr.length<span class="operator">-</span><span class="number">1</span>;
                  j++) {
                  <span class="comment">// Comparison and swap logic</span>
                  }
                  }
                  }
          </div>
        </div>
        <div class="subtopic">
          <h3><i class="fas fa-sync"></i> Insertion Sort</h3>
          <p>The algorithm iterates through an array, taking each element and inserting it into its correct
            position within the already sorted part of the array.</p>
          <div class="code-example">
            <span class="comment">// Insertion Sort Implementation</span>
            <span class="function">INSERTION-SORT</span>(A, n) <span class="comment">// A[1..n]</span>
            <span class="keyword">for</span> j ? <span class="number">2</span> <span class="keyword">to</span> n
            <span class="keyword">do</span> key ? A[j]
            i ? j <span class="operator">-</span> <span class="number">1</span>
            <span class="keyword">while</span> i > <span class="number">0</span> <span class="keyword">and</span> A[i] >
            key
            <span class="keyword">do</span> A[i<span class="operator">+</span><span class="number">1</span>] ? A[i]
            i ? i<span class="operator">-</span><span class="number">1</span>
            A[i<span class="operator">+</span><span class="number">1</span>] = key
          </div>
          <div class="complexity-box">
            <h5><i class="fas fa-stopwatch"></i> Time Complexity Analysis</h5>
            <ul>
              <li><strong>Worst-case:</strong> When the input is reverse-sorted -&gt; <span class="math">T(n�)</span>
              </li>
              <li><strong>Average-case:</strong> <span class="math">T(n�)</span></li>
              <li><strong>Best-case:</strong> When input is already sorted -&gt; <span class="math">T(n)</span></li>
            </ul>
          </div>
        </div>
        <div class="subtopic">
          <h3><i class="fas fa-star"></i> Merge Sort</h3>
          <p>A <strong>divide-and-conquer</strong> algorithm that efficiently sorts large arrays.</p>
          <div class="code-example">
            <span class="comment">// Merge Sort - Divide and Conquer</span>
            <span class="function">MERGE-SORT</span>(A, p, r)
            <span class="keyword">if</span> p < r q=?(p + r) / <span class="number">2</span>?
              <span class="function">MERGE-SORT</span>(A, p, q)
              <span class="function">MERGE-SORT</span>(A, q + <span class="number">1</span>, r)
              <span class="function">MERGE</span>(A, p, q, r)
              <span class="function">MERGE</span>(A, p, q, r)
              <span class="comment">// Merge two sorted subarrays A[p..q] and A[q+1..r]</span>
              <span class="comment">// Takes T(n) time</span>
          </div>
          <div class="complexity-box">
            <h5><i class="fas fa-rocket"></i> Performance</h5>
            <p>The recurrence for merge sort solves to a running time of <span class="math">T(n lg n)</span>,
              which is asymptotically more efficient than insertion sort.</p>
            <p><strong>In practice:</strong> Merge sort beats insertion sort for n = 30.</p>
          </div>
        </div>
      </div>
      >
    </div>
    <!-- Asymptotic Notation -->
    <div class="topic-section" id="lecture2">
      <div class="topic-header">
        <h2><i class="fas fa-bullseye"></i> Asymptotic Notation & Recurrences</h2>
        <div class="difficulty intermediate">Intermediate</div>
      </div>
      <div class="topic-content">
        <div class="subtopic">
          <h3><i class="fas fa-bullseye"></i> Asymptotic Notation</h3>
          <p>To analyze the growth rate of an algorithm's running time as the input size (n) approaches infinity,
            while ignoring machine-dependent constants.</p>
          <div class="code-example">
            <span class="comment">// Big-O Examples</span>
            <span class="comment">// Drop low-order terms and ignore leading constants</span>
            <span class="number">3</span>n� + <span class="number">90</span>n� - <span class="number">5</span>n + <span
              class="number">6046</span> = <span class="function">T</span>(n�)
            <span class="comment">// Time Complexity Comparison</span>
            <span class="function">O</span>(<span class="number">1</span>) <span class="comment">// Constant - Array
              access</span>
            <span class="function">O</span>(log n) <span class="comment">// Logarithmic - Binary search</span>
            <span class="function">O</span>(n) <span class="comment">// Linear - Linear search</span>
            <span class="function">O</span>(n log n) <span class="comment">// N-Log-N - Merge sort</span>
            <span class="function">O</span>(n�) <span class="comment">// Quadratic - Insertion sort</span>
            <span class="function">O</span>(<span class="number">2</span>n) <span class="comment">// Exponential - Naive
              Fibonacci</span>
          </div>
        </div>
        <div class="subtopic">
          <h3><i class="fas fa-wrench"></i> Divide-and-Conquer Recurrences</h3>
          <p>Methods for solving recurrences: Iteration, Substitution, Recursion Tree, and Master Method.</p>
          <div class="code-example">
            <span class="comment">// Master Method Template</span>
            <span class="function">T</span>(n) = a<span class="function">T</span>(n/b) + f(n)
            <span class="comment">// Examples:</span>
            <span class="comment">// Binary Search: T(n) = 1T(n/2) + T(1) -&gt; T(lg n)</span>
            <span class="comment">// Merge Sort: T(n) = 2T(n/2) + T(n) -&gt; T(n lg n)</span>
            <span class="comment">// Strassen's: T(n) = 7T(n/2) + T(n�) -&gt; T(n^lg7)</span>
          </div>
        </div>
      </div>
    </div>
    <!-- Order Statistics & Quicksort -->
    <div class="topic-section" id="lecture3">
      <div class="topic-header">
        <h2><i class="fas fa-search"></i> Order Statistics & Quicksort</h2>
        <div class="difficulty advanced">Advanced</div>
      </div>
      <div class="topic-content">
        <div class="subtopic">
          <h3><i class="fas fa-bullseye"></i> Selection Problem</h3>
          <p><strong>Goal:</strong> Select the i-th smallest of n elements (element with rank i)</p>
          <div class="code-example">
            <span class="comment">// Randomized Selection Algorithm</span>
            <span class="function">RAND-SELECT</span>(A, p, r, i)
            <span class="keyword">if</span> p == r
            <span class="keyword">return</span> A[p]
            q = <span class="function">RANDOMIZED-PARTITION</span>(A, p, r)
            k = q - p + <span class="number">1</span>
            <span class="keyword">if</span> i == k
            <span class="keyword">return</span> A[q]
            <span class="keyword">else if</span> i < k <span class="keyword">return</span> <span
                class="function">RAND-SELECT</span>(A, p, q<span class="operator">-</span><span class="number">1</span>,
              i)
              <span class="keyword">else</span>
              <span class="keyword">return</span> <span class="function">RAND-SELECT</span>(A, q+<span
                class="number">1</span>, r, i<span class="operator">-</span>k)
              <span class="comment">// Expected Time: T(n) - excellent in practice!</span>
          </div>
        </div>
        <div class="subtopic">
          <h3><i class="fas fa-bolt"></i> Quicksort Algorithm</h3>
          <p>Proposed by C.A.R. Hoare in 1962. A divide-and-conquer algorithm that sorts "in place".</p>
          <div class="code-example">
            <span class="comment">// Quicksort Implementation</span>
            <span class="function">QUICKSORT</span>(A, p, r)
            <span class="keyword">if</span> p < r q=<span class="function">PARTITION</span>(A, p, r)
              <span class="function">QUICKSORT</span>(A, p, q<span class="operator">-</span><span
                class="number">1</span>)
              <span class="function">QUICKSORT</span>(A, q+<span class="number">1</span>, r)
              <span class="function">PARTITION</span>(A, p, r)
              x = A[r] <span class="comment">// Pivot is the last element</span>
              i = p <span class="operator">-</span> <span class="number">1</span>
              <span class="keyword">for</span> j = p <span class="keyword">to</span> r<span
                class="operator">-</span><span class="number">1</span>
              <span class="keyword">if</span> A[j] = x
              i = i + <span class="number">1</span>
              <span class="function">exchange</span> A[i] ? A[j]
              <span class="function">exchange</span> A[i+<span class="number">1</span>] ? A[r]
              <span class="keyword">return</span> i+<span class="number">1</span>
              <span class="comment">// Best-case: T(n lg n), Worst-case: T(n�)</span>
              <span class="comment">// Expected (randomized): T(n lg n)</span>
          </div>
        </div>
      </div>
    </div>
    <!-- Continue with rest of sections... -->
    <div class="topic-section" id="lecture4">
      <div class="topic-header">
        <h2>#<i class="fas fa-star"></i> Hashing & Amortized Analysis</h2>
        <div class="difficulty intermediate">Intermediate</div>
      </div>
      <div class="topic-content">
        <div class="subtopic">
          <h3><i class="fas fa-key"></i> Hash Tables</h3>
          <p>Hashing provides a way to store and retrieve data with average-case constant time operations.</p>
          <div class="code-example">
            <span class="comment">// Hash Table with Chaining</span>
            <span class="keyword">class</span> <span class="type">HashTable</span> {
            <span class="keyword">private</span> <span class="type">LinkedList</span><span class="operator">
              << /span><span class="type">Entry</span><span class="operator">></span>[] table;
                <span class="keyword">private</span> <span class="type">int</span> size;
                <span class="comment">// Hash function</span>
                <span class="keyword">private</span> <span class="type">int</span> <span
                  class="function">hash</span>(<span class="type">String</span> key) {
                <span class="keyword">return</span> <span class="function">Math.abs</span>(key.<span
                  class="function">hashCode</span>()) % size;
                }
                <span class="comment">// Insert operation - O(1) average case</span>
                <span class="keyword">public</span> <span class="keyword">void</span> <span
                  class="function">put</span>(<span class="type">String</span> key, <span class="type">int</span> value)
                {
                <span class="type">int</span> index = <span class="function">hash</span>(key);
                <span class="comment">// Handle collision with chaining</span>
                table[index].<span class="function">add</span>(<span class="keyword">new</span> <span
                  class="function">Entry</span>(key, value));
                }
                }
                <span class="comment">// Load factor a = n/m should be kept low</span>
                <span class="comment">// Expected search time: O(1 + a)</span>
          </div>
        </div>
      </div>
      >
      <p>A data structure that uses a special hash function to map a key to a particular value for faster
        access. The efficiency depends on the hash function's quality.</p>
      <div class="complexity-box">
        <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
        <ul>
          <li><strong>Best/Average Case:</strong> O(1)</li>
          <li><strong>Worst Case:</strong> O(n)</li>
        </ul>
      </div>
    </div>
    <div class="topics-grid">
      <div class="topic-card">
        <h5><i class="fas fa-bullseye"></i> Hash Functions</h5>
        <div class="algorithm-box">
          <h4>Division Method</h4>
          <div class="formula">h(k) = k mod n</div>
          <p>Best when n is prime for uniform distribution</p>
          <h4>Multiplication Method</h4>
          <div class="formula">h(k) = ?n(kA mod 1)?</div>
          <p>Value of n is not critical</p>
          <h4>Mid-Square Method</h4>
          <p>Square the key and extract middle digits</p>
          <h4>Folding Method</h4>
          <p>Partition key into parts and add them</p>
        </div>
      </div>
      <div class="topic-card">
        <h5><i class="fas fa-link"></i> Separate Chaining</h5>
        <p><strong>Open Hashing:</strong> Use linked lists to store multiple entries that hash to the same
          index</p>
        <div class="complexity-box">
          <h5>Performance</h5>
          <ul>
            <li><strong>Load Factor:</strong> a = n/m</li>
            <li><strong>Expected Time:</strong> O(1 + a)</li>
            <li><strong>Worst-case:</strong> O(n) - all elements in one chain</li>
          </ul>
        </div>
        <div class="theorem-box">
          <h4><i class="fas fa-star"></i> Extended Techniques</h4>
          <ul>
            <li><strong>BST chains:</strong> O(lg n) search time</li>
            <li><strong>AVL trees:</strong> Guaranteed O(lg n) operations</li>
          </ul>
        </div>
      </div>
      <div class="topic-card">
        <h5><i class="fas fa-bullseye"></i> Open Addressing</h5>
        <p><strong>Closed Hashing:</strong> All items stored in hash table itself, one item per slot</p>
        <div class="algorithm-box">
          <h4>Probing Techniques</h4>
          <div class="theorem-box">
            <h4>Linear Probing</h4>
            <div class="formula">h(k,i) = (h'(k) + i) mod m</div>
            <p><strong>Problem:</strong> Primary clustering</p>
            <h4>Quadratic Probing</h4>
            <div class="formula">h(k,i) = (h'(k) + i�) mod m</div>
            <p><strong>Problem:</strong> Secondary clustering</p>
            <h4>Double Hashing</h4>
            <div class="formula">h(k,i) = (h1(k) + i�h2(k)) mod m</div>
            <p><strong>Advantage:</strong> No clustering</p>
          </div>
        </div>
      </div>
    </div>
    <table class="comparison-table">
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Separate Chaining</th>
          <th>Open Addressing</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Implementation</strong></td>
          <td>Simpler to implement</td>
          <td>Requires careful handling</td>
        </tr>
        <tr>
          <td><strong>Memory Usage</strong></td>
          <td>Extra space for pointers</td>
          <td>Better space efficiency</td>
        </tr>
        <tr>
          <td><strong>Cache Performance</strong></td>
          <td>Poor due to linked lists</td>
          <td>Better cache locality</td>
        </tr>
        <tr>
          <td><strong>Load Factor Sensitivity</strong></td>
          <td>Less sensitive</td>
          <td>More sensitive</td>
        </tr>
        <tr>
          <td><strong>Deletion</strong></td>
          <td>Easy</td>
          <td>Difficult (need tombstones)</td>
        </tr>
      </tbody>
    </table>
    <div class="subsection">
      <h3 class="subsection-title">2. Amortized Analysis</h3>
      <div class="algorithm-box">
        <h4><i class="fas fa-dollar-sign"></i> Purpose of Amortized Analysis</h4>
        <p>Analyzes a sequence of operations to guarantee a worst-case average time that is lower than the
          worst-case time of a single, expensive operation.</p>
      </div>
      <div class="topics-grid">
        <div class="topic-card">
          <h5><i class="fas fa-chart-bar"></i> Aggregate Method</h5>
          <p>Find total cost of n operations, averaging expensive operations over the sequence</p>
          <div class="algorithm-box">
            <h4>Dynamic Array Example</h4>
            <ul>
              <li>When array fills up, create new table (double size)</li>
              <li>Copy contents to new table</li>
              <li><strong>Naive analysis:</strong> O(n�) for n insertions</li>
              <li><strong>Amortized analysis:</strong> O(n) total -&gt; O(1) per insertion</li>
            </ul>
          </div>
        </div>
        <div class="topic-card">
          <h5><i class="fas fa-star"></i> Accounting Method</h5>
          <p>Charges a constant amortized cost for each operation, storing unused "credit" to pay for future
            expensive operations</p>
          <div class="warning-box">
            <h4><i class="fas fa-exclamation-triangle"></i> Important Rule</h4>
            <p>The bank balance must never be negative!</p>
          </div>
        </div>
        <div class="topic-card">
          <h5><i class="fas fa-bolt"></i> Potential Method</h5>
          <p>Related to the accounting method, uses a potential function to analyze the amortized cost</p>
          <div class="formula">
            Amortized Cost = Actual Cost + ? Potential
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Linear Sorting & Cryptographic Hashing -->
  <div class="topic-section" id="lecture5">
    <div class="topic-header">
      <h2><i class="fas fa-star"></i> Linear-Time Sorting & Cryptographic Hashing</h2>
      <div class="difficulty advanced">Advanced</div>
    </div>
    <div class="topic-content">
      <div class="subtopic">
        <h3><i class="fas fa-star"></i> Sorting Lower Bounds</h3>
        <p>Algorithms that only use comparisons to determine the relative order of elements (e.g., insertion
          sort, merge sort, quicksort).</p>
        <div class="code-example">
          <span class="comment">// Decision Tree Model</span>
          <span class="comment">// Each internal node represents a comparison between two elements</span>
          <span class="comment">// Each leaf represents a unique sorted permutation of the input</span>
          <span class="comment">// The worst-case running time = height of the decision tree</span>
          <span class="comment">// Lower Bound Theorem:</span>
          <span class="comment">// Any decision tree that can sort n elements must have height = O(n lg n)</span>
          <span class="comment">// Proof: There are n! possible permutations, and a binary tree</span>
          <span class="comment">// of height h can have at most 2^h leaves.</span>
          <span class="comment">// Therefore, n! = 2^h, which implies h = lg(n!) = O(n lg n)</span>
          <span class="comment">// Conclusion: Merge sort and heapsort are asymptotically optimal!</span>
        </div>
      </div>
      <div class="subtopic">
        <h3><i class="fas fa-chart-bar"></i> Counting Sort</h3>
        <p>Non-comparison sort for integers in small range [1..k]. Breaking the T(n lg n) barrier!</p>
        <div class="code-example">
          <span class="comment">// Counting Sort Algorithm</span>
          <span class="function">COUNTING-SORT</span>(A, B, k)
          <span class="comment">// A: input array, B: output array, k: range [1..k]</span>
          <span class="keyword">let</span> C = <span class="keyword">new</span> <span class="function">Array</span>(k +
          <span class="number">1</span>).<span class="function">fill</span>(<span class="number">0</span>)
          <span class="comment">// Step 1: Count occurrences</span>
          <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> A.length
          C[A[i]] = C[A[i]] + <span class="number">1</span>
          <span class="comment">// Step 2: Cumulative counts (positions)</span>
          <span class="keyword">for</span> i = <span class="number">2</span> <span class="keyword">to</span> k
          C[i] = C[i] + C[i<span class="operator">-</span><span class="number">1</span>]
          <span class="comment">// Step 3: Build output array (stable)</span>
          <span class="keyword">for</span> i = A.length <span class="keyword">downto</span> <span
            class="number">1</span>
          B[C[A[i]]] = A[i]
          C[A[i]] = C[A[i]] <span class="operator">-</span> <span class="number">1</span>
          <span class="comment">// Time Complexity: T(n + k)</span>
          <span class="comment">// When k = O(n): T(n) time!</span>
          <span class="comment">// Space Complexity: T(k)</span>
          <span class="comment">// Stability: YES - preserves original order of equal elements</span>
        </div>
      </div>
      <div class="subtopic">
        <h3><i class="fas fa-bullseye"></i> Radix Sort</h3>
        <p>Digit-by-digit sort using stable auxiliary sort. Sort on least-significant digit first!</p>
        <div class="code-example">
          <span class="comment">// Radix Sort Algorithm</span>
          <span class="function">RADIX-SORT</span>(A, d)
          <span class="comment">// A: array of d-digit numbers</span>
          <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> d
          <span class="comment">// Use stable sort (counting sort) on digit i</span>
          <span class="function">COUNTING-SORT</span>(A, i)
          <span class="comment">// Time Complexity: T(n,b) = T(b/r � (n + 2^r))</span>
          <span class="comment">// Where: n = elements, b = bits per word, r = bits per digit</span>
          <span class="comment">// Optimal r = lg n minimizes time to T(bn/lg n)</span>
          <span class="comment">// Example: Sort 32-bit integers</span>
          <span class="comment">// If n = 10^6, then r = lg(10^6) � 20</span>
          <span class="comment">// Time = T(32 � 10^6 / 20) = T(1.6 � 10^6)</span>
        </div>
      </div>
      <div class="subtopic">
        <h3><i class="fas fa-lock"></i> Cryptographic Hashing</h3>
        <p>A mathematical algorithm that maps data of arbitrary size to a fixed-size bit array (hash value).
          It's a one-way function that is practically infeasible to invert.</p>
        <div class="code-example">
          <span class="comment">// Cryptographic Hash Properties</span>
          <span class="comment">// 1. Deterministic: Same message -&gt; same hash</span>
          <span class="comment">// 2. Quick to compute: Fast hash computation</span>
          <span class="comment">// 3. Pre-image resistance: Hard to find message for given hash</span>
          <span class="comment">// 4. Second pre-image resistance: Hard to find different input with same hash</span>
          <span class="comment">// 5. Collision resistance: Hard to find two messages with same hash</span>
          <span class="comment">// 6. Avalanche effect: Small input change -&gt; big hash change</span>
          <span class="comment">// Digital Signature Process</span>
          <span class="comment">// Sender Side:</span>
          <span class="comment">// 1. Hash the message to create digest</span>
          <span class="comment">// 2. Encrypt digest with private key (signature)</span>
          <span class="comment">// 3. Send message + signature</span>
          <span class="comment">// Receiver Side:</span>
          <span class="comment">// 1. Hash the received message</span>
          <span class="comment">// 2. Decrypt signature with sender's public key</span>
          <span class="comment">// 3. Compare the two hashes</span>
          <span class="comment">// 4. If match -&gt; authentic & unmodified</span>
          <span class="comment">// Strengthening Techniques:</span>
          <span class="comment">// - Salted hashes: Add random data before hashing</span>
          <span class="comment">// - HMAC: Keyed hash with cryptographic key</span>
          <span class="comment">// - Adaptive functions: PBKDF2, bcrypt - intentionally slow</span>
        </div>
      </div>
    </div>
  </div>
  <!-- Dynamic Programming -->
  <div class="topic-section" id="lecture10">
    <div class="topic-header">
      <h2><i class="fas fa-star"></i> Dynamic Programming</h2>
      <div class="difficulty advanced">Advanced</div>
    </div>
    <div class="topic-content">
      <div class="subtopic">
        <h3><i class="fas fa-brain"></i> Introduction to Dynamic Programming</h3>
        <p>A method for designing algorithms that solves problems by breaking them down into simpler, overlapping
          subproblems. It's typically used for optimization problems.</p>
        <p><strong>Key idea:</strong> Solve each subproblem only once and store its solution to avoid redundant
          computations.</p>
        <div class="code-example">
          <span class="comment">// Two Essential Properties for DP:</span>
          <span class="comment">// 1. Optimal Substructure:</span>
          <span class="comment">// An optimal solution to the overall problem contains</span>
          <span class="comment">// within it an optimal solution to subproblems</span>
          <span class="comment">// 2. Overlapping Subproblems:</span>
          <span class="comment">// The recursive solution recomputes the same</span>
          <span class="comment">// subproblems over and over again</span>
          <span class="comment">// Two Approaches to Dynamic Programming:</span>
          <span class="comment">// Top-Down with Memoization:</span>
          <span class="comment">// - Recursive algorithm that checks a table first</span>
          <span class="comment">// - If solution exists, return it</span>
          <span class="comment">// - Otherwise, compute and store result</span>
          <span class="comment">// Bottom-Up Method:</span>
          <span class="comment">// - Iteratively solve subproblems from smallest to largest</span>
          <span class="comment">// - Build up solutions using previously computed results</span>
        </div>
      </div>
      <div class="subtopic">
        <h3><i class="fas fa-star"></i> Rod Cutting Problem</h3>
        <p>Given a rod of length n and a table of prices p<sub>i</sub> for each piece length i = 1, 2, ..., n.
          Find the maximum revenue r<sub>n</sub> by cutting the rod and selling the pieces.</p>
        <div class="code-example">
          <span class="comment">// Recursive Formula:</span>
          <span class="comment">// r_n = max(p_i + r_{n-i}) for 1 = i = n</span>
          <span class="comment">// Base case: r_0 = 0</span>
          <span class="comment">// <i class="fas fa-times"></i> Naive Recursive Solution - EXPONENTIAL TIME!</span>
          <span class="function">CUT-ROD</span>(p, n)
          <span class="keyword">if</span> n == <span class="number">0</span>
          <span class="keyword">return</span> <span class="number">0</span>
          q = <span class="operator">-</span>8
          <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n
          q = <span class="function">max</span>(q, p[i] + <span class="function">CUT-ROD</span>(p, n<span
            class="operator">-</span>i))
          <span class="keyword">return</span> q
          <span class="comment">// Problem: T(n) = 2^n due to redundant calculations!</span>
          <span class="comment">// <i class="fas fa-check"></i> Top-Down with Memoization - T(n�) time</span>
          <span class="function">MEMOIZED-CUT-ROD</span>(p, n)
          <span class="keyword">let</span> r[<span class="number">0</span>..n] <span class="keyword">be new array</span>
          <span class="keyword">for</span> i = <span class="number">0</span> <span class="keyword">to</span> n
          r[i] = <span class="operator">-</span>8
          <span class="keyword">return</span> <span class="function">MEMOIZED-CUT-ROD-AUX</span>(p, n, r)
          <span class="function">MEMOIZED-CUT-ROD-AUX</span>(p, n, r)
          <span class="keyword">if</span> r[n] >= <span class="number">0</span>
          <span class="keyword">return</span> r[n] <span class="comment">// Already computed</span>
          <span class="keyword">if</span> n == <span class="number">0</span>
          q = <span class="number">0</span>
          <span class="keyword">else</span>
          q = <span class="operator">-</span>8
          <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n
          q = <span class="function">max</span>(q, p[i] + <span class="function">MEMOIZED-CUT-ROD-AUX</span>(p, n<span
            class="operator">-</span>i, r))
          r[n] = q <span class="comment">// Store result</span>
          <span class="keyword">return</span> q
          <span class="comment">// <i class="fas fa-building"></i> Bottom-Up Method - T(n�) time</span>
          <span class="function">BOTTOM-UP-CUT-ROD</span>(p, n)
          <span class="keyword">let</span> r[<span class="number">0</span>..n] <span class="keyword">be new array</span>
          r[<span class="number">0</span>] = <span class="number">0</span>
          <span class="keyword">for</span> j = <span class="number">1</span> <span class="keyword">to</span> n
          q = <span class="operator">-</span>8
          <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> j
          q = <span class="function">max</span>(q, p[i] + r[j<span class="operator">-</span>i])
          r[j] = q
          <span class="keyword">return</span> r[n]
          <span class="comment">// Time Complexity: T(n�) - much better than exponential!</span>
          <span class="comment">// Space Complexity: T(n)</span>
        </div>
      </div>
      <div class="subtopic">
        <h3><i class="fas fa-star"></i> Matrix Chain Multiplication</h3>
        <div class="subtopic">
          <h3><i class="fas fa-star"></i> Matrix Chain Multiplication</h3>
          <p>Given a sequence of n matrices A1, A2, ..., A<sub>n</sub> with dimensions p0�p1, p1�p2, ...,
            p<sub>n-1</sub>�p<sub>n</sub>. Find the optimal parenthesization that minimizes the total number of
            scalar multiplications to compute A1A2...A<sub>n</sub>.</p>
          <div class="code-example">
            <span class="comment">// Key Insight: Matrix multiplication is associative!</span>
            <span class="comment">// Different parenthesizations can have dramatically different costs</span>
            <span class="comment">// Example: A1: 1�100, A2: 100�1, A3: 1�100</span>
            <span class="comment">// ((A1A2)A3): 1�100�1 + 1�1�100 = 200 multiplications</span>
            <span class="comment">// (A1(A2A3)): 100�1�100 + 1�100�100 = 20,000 multiplications</span>
            <span class="comment">// Recursive Structure:</span>
            <span class="comment">// To multiply matrices from A_i to A_j, split at point k (i = k < j)</span>
                <span class="comment">// m[i,j] = min(m[i,k] + m[k+1,j] + p_{i-1}*p_k*p_j) for i = k < j</span>
                    <span class="comment">// Base case: m[i,i] = 0</span>
                    <span class="comment">// DP Algorithm</span>
                    <span class="function">MATRIX-CHAIN-ORDER</span>(p)
                    n = p.length <span class="operator">-</span> <span class="number">1</span>
                    <span class="keyword">let</span> m[<span class="number">1</span>..n, <span
                      class="number">1</span>..n] <span class="keyword">and</span> s[<span
                      class="number">1</span>..n<span class="operator">-</span><span class="number">1</span>, <span
                      class="number">2</span>..n] <span class="keyword">be new tables</span>
                    <span class="comment">// Initialize diagonal to 0</span>
                    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n
                    m[i, i] = <span class="number">0</span>
                    <span class="comment">// Fill table for chain lengths 2 to n</span>
                    <span class="keyword">for</span> l = <span class="number">2</span> <span class="keyword">to</span> n
                    <span class="comment">// l is chain length</span>
                    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n
                    <span class="operator">-</span> l + <span class="number">1</span>
                    j = i + l <span class="operator">-</span> <span class="number">1</span>
                    m[i, j] = 8
                    <span class="keyword">for</span> k = i <span class="keyword">to</span> j <span
                      class="operator">-</span> <span class="number">1</span>
                    q = m[i, k] + m[k+<span class="number">1</span>, j] + p[i<span class="operator">-</span><span
                      class="number">1</span>]<span class="operator">*</span>p[k]<span class="operator">*</span>p[j]
                    <span class="keyword">if</span> q < m[i, j] m[i, j]=q s[i, j]=k <span class="comment">// Remember
                      split point</span>
                <span class="keyword">return</span> m <span class="keyword">and</span> s
                <span class="comment">// Reconstructing Optimal Solution</span>
                <span class="function">PRINT-OPTIMAL-PARENS</span>(s, i, j)
                <span class="keyword">if</span> i == j
                <span class="function">print</span> <span class="string">"A"</span> + i
                <span class="keyword">else</span>
                <span class="function">print</span> <span class="string">"("</span>
                <span class="function">PRINT-OPTIMAL-PARENS</span>(s, i, s[i, j])
                <span class="function">PRINT-OPTIMAL-PARENS</span>(s, s[i, j] + <span class="number">1</span>, j)
                <span class="function">print</span> <span class="string">")"</span>
                <span class="comment">// Time Complexity: T(n�)</span>
                <span class="comment">// Space Complexity: T(n�)</span>
          </div>
        </div>
        <div class="subtopic">
          <h3><i class="fas fa-edit"></i> Longest Common Subsequence (LCS)</h3>
          <p>Given two sequences X = ?x1, x2, ..., x<sub>m</sub>? and Y = ?y1, y2, ..., y<sub>n</sub>?. Find a
            longest subsequence common to both X and Y.</p>
          <p><strong>Note:</strong> A subsequence can be derived by deleting some elements without changing the
            order of remaining elements.</p>
          <div class="code-example">
            <span class="comment">// Recursive Structure for LCS length c[i,j]:</span>
            <span class="comment">// If x_i = y_j: c[i,j] = c[i-1,j-1] + 1</span>
            <span class="comment">// If x_i != y_j: c[i,j] = max(c[i-1,j], c[i,j-1])</span>
            <span class="comment">// Base cases: c[i,0] = 0 and c[0,j] = 0</span>
            <span class="function">LCS-LENGTH</span>(X, Y)
            m = X.length
            n = Y.length
            <span class="keyword">let</span> b[<span class="number">1</span>..m, <span class="number">1</span>..n] <span
              class="keyword">and</span> c[<span class="number">0</span>..m, <span class="number">0</span>..n] <span
              class="keyword">be new tables</span>
            <span class="comment">// Initialize base cases</span>
            <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> m
            c[i, <span class="number">0</span>] = <span class="number">0</span>
            <span class="comment">// Fill the DP table</span>
            <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> m
            <span class="keyword">for</span> j = <span class="number">1</span> <span class="keyword">to</span> n
            <span class="keyword">if</span> X[i] == Y[j]
            c[i, j] = c[i<span class="operator">-</span><span class="number">1</span>, j<span
              class="operator">-</span><span class="number">1</span>] + <span class="number">1</span>
            b[i, j] = <span class="string">"?"</span> <span class="comment">// diagonal</span>
            <span class="keyword">else if</span> c[i<span class="operator">-</span><span class="number">1</span>, j] >=
            c[i, j<span class="operator">-</span><span class="number">1</span>]
            c[i, j] = c[i<span class="operator">-</span><span class="number">1</span>, j]
            b[i, j] = <span class="string">"?"</span> <span class="comment">// up</span>
            <span class="keyword">else</span>
            c[i, j] = c[i, j<span class="operator">-</span><span class="number">1</span>]
            b[i, j] = <span class="string">"?"</span> <span class="comment">// left</span>
            <span class="keyword">return</span> c <span class="keyword">and</span> b
            <span class="comment">// Reconstructing the LCS</span>
            <span class="function">PRINT-LCS</span>(b, X, i, j)
            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j ==
            <span class="number">0</span>
            <span class="keyword">return</span>
            <span class="keyword">if</span> b[i, j] == <span class="string">"?"</span>
            <span class="function">PRINT-LCS</span>(b, X, i<span class="operator">-</span><span class="number">1</span>,
            j<span class="operator">-</span><span class="number">1</span>)
            <span class="function">print</span> X[i]
            <span class="keyword">else if</span> b[i, j] == <span class="string">"?"</span>
            <span class="function">PRINT-LCS</span>(b, X, i<span class="operator">-</span><span class="number">1</span>,
            j)
            <span class="keyword">else</span>
            <span class="function">PRINT-LCS</span>(b, X, i, j<span class="operator">-</span><span
              class="number">1</span>)
            <span class="comment">// Example: X = "ABCBDAB", Y = "BDCABA"</span>
            <span class="comment">// LCS = "BCBA" (length = 4)</span>
            <span class="comment">// Time Complexity: T(mn)</span>
            <span class="comment">// Space Complexity: T(mn)</span>
            <span class="comment">// Applications:</span>
            <span class="comment">// - DNA sequence comparison</span>
            <span class="comment">// - File differencing (diff utility)</span>
            <span class="comment">// - Version control systems</span>
            <span class="comment">// - Plagiarism detection</span>
          </div>
        </div>
      </div>
    </div>
    <!-- Greedy Algorithms -->
    <div class="topic-section" id="lecture13">
      <div class="topic-header">
        <h2><i class="fas fa-bullseye"></i> Greedy Algorithms</h2>
        <div class="difficulty intermediate">Intermediate</div>
      </div>
      <div class="topic-content">
        <div class="subtopic">
          <h3><i class="fas fa-brain"></i> Introduction to Greedy Algorithms</h3>
          <p>A greedy algorithm makes a locally optimal choice at each step with the hope that this choice will
            lead to a globally optimal solution. It doesn't always guarantee an optimal solution, but for some
            problems, it does.</p>
          <div class="code-example">
            <span class="comment">// Key Components of Greedy Strategy:</span>
            <span class="comment">// 1. Greedy-choice property:</span>
            <span class="comment">// A global optimal solution can be reached by making</span>
            <span class="comment">// a local optimal choice</span>
            <span class="comment">// 2. Optimal substructure:</span>
            <span class="comment">// An optimal solution contains within it optimal</span>
            <span class="comment">// solutions to subproblems</span>
            <span class="comment">// Greedy vs Dynamic Programming:</span>
            <span class="comment">// Greedy: Make choice -&gt; solve remaining subproblem</span>
            <span class="comment">// DP: Solve all subproblems -&gt; make informed choice</span>
            <span class="comment">// Greedy Algorithm Template:</span>
            <span class="function">GREEDY-ALGORITHM</span>(input)
            solution = �
            <span class="keyword">while</span> <span class="keyword">not</span> <span
              class="function">done</span>(solution)
            choice = <span class="function">select</span>(input) <span class="comment">// Make greedy choice</span>
            input = input <span class="operator">-</span> choice <span class="comment">// Remove selected element</span>
            solution = solution ? choice
            <span class="keyword">return</span> solution
          </div>
        </div>
        <div class="subtopic">
          <h3><i class="fas fa-star"></i> Activity Selection Problem</h3>
          <div class="algorithm-box">
            <h4><i class="fas fa-star"></i> Problem Statement</h4>
            <p>Given a set of n activities, each with a start time s<sub>i</sub> and finish time f<sub>i</sub>.
              Select the maximum number of mutually compatible activities. Two activities are compatible if their
              time intervals do not overlap.</p>
            <p><strong>Assumption:</strong> Activities are sorted by finish time (f1 = f2 = ... = f<sub>n</sub>)</p>
          </div>
          <div class="topics-grid">
            <div class="topic-card">
              <h5><i class="fas fa-bullseye"></i> Greedy Strategy</h5>
              <p><strong>Key insight:</strong> Always choose the activity that finishes earliest among remaining
                activities.</p>
              <div class="algorithm-box">
                <h4>Why This Works</h4>
                <p>Choosing the earliest-finishing activity leaves the most room for future activities, maximizing
                  our options.</p>
              </div>
            </div>
            <div class="topic-card">
              <h5><i class="fas fa-laptop-code"></i> Algorithm</h5>
              <div class="code-block">
                GREEDY-ACTIVITY-SELECTOR(s, f)
                n = s.length
                A = {a1} // Select first activity
                k = 1
                for m = 2 to n
                if s[m] >= f[k] // Activity m is compatible
                A = A ? {a_m}
                k = m
                return A
              </div>
              <div class="complexity-box">
                <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                <p>T(n) after activities are sorted by finish time</p>
              </div>
            </div>
            <div class="topic-card">
              <h5><i class="fas fa-check"></i> Proof of Optimality</h5>
              <div class="theorem-box">
                <h4><i class="fas fa-bullseye"></i> Greedy Choice Property</h4>
                <p>The greedy choice (earliest finish time) is always part of some optimal solution.</p>
                <p><strong>Proof sketch:</strong> If optimal solution doesn't include earliest-finishing activity,
                  we can replace the first activity in optimal solution with earliest-finishing activity without
                  making the solution worse.</p>
              </div>
            </div>
          </div>
        </div>
        <div class="subsection">
          <h3 class="subsection-title">3. Huffman Codes</h3>
          <div class="algorithm-box">
            <h4><i class="fas fa-star"></i> Data Compression Problem</h4>
            <p>Given a set of characters and their frequencies, find an optimal prefix code to represent them. A
              prefix code is a binary code where no codeword is a prefix of another. Goal: minimize total bits
              needed to encode a message.</p>
          </div>
          <div class="theorem-box">
            <h4><i class="fas fa-chart-bar"></i> Example: Character Frequencies</h4>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Character</th>
                  <th>Frequency</th>
                  <th>Fixed-length Code</th>
                  <th>Huffman Code</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>a</td>
                  <td>45</td>
                  <td>000</td>
                  <td>0</td>
                </tr>
                <tr>
                  <td>b</td>
                  <td>13</td>
                  <td>001</td>
                  <td>101</td>
                </tr>
                <tr>
                  <td>c</td>
                  <td>12</td>
                  <td>010</td>
                  <td>100</td>
                </tr>
                <tr>
                  <td>d</td>
                  <td>16</td>
                  <td>011</td>
                  <td>111</td>
                </tr>
                <tr>
                  <td>e</td>
                  <td>9</td>
                  <td>100</td>
                  <td>1101</td>
                </tr>
                <tr>
                  <td>f</td>
                  <td>5</td>
                  <td>101</td>
                  <td>1100</td>
                </tr>
              </tbody>
            </table>
            <div class="complexity-box">
              <h5><i class="fas fa-star"></i> Space Savings</h5>
              <ul>
                <li><strong>Fixed-length:</strong> 3 bits/char � 100 chars = 300 bits</li>
                <li><strong>Huffman:</strong> (45�1 + 13�3 + 12�3 + 16�3 + 9�4 + 5�4) = 224 bits</li>
                <li><strong>Savings:</strong> 25% compression!</li>
              </ul>
            </div>
          </div>
          <div class="topics-grid">
            <div class="topic-card">
              <h5><i class="fas fa-star"></i> Building Huffman Tree</h5>
              <div class="algorithm-box">
                <h4>Greedy Strategy</h4>
                <p>Always merge the two nodes with smallest frequencies first.</p>
              </div>
            </div>
            <div class="topic-card">
              <h5><i class="fas fa-laptop-code"></i> Huffman Algorithm</h5>
              <div class="code-block">
                HUFFMAN(C)
                n = |C|
                Q = C // Min-priority queue
                for i = 1 to n - 1
                allocate a new node z
                z.left = x = EXTRACT-MIN(Q)
                z.right = y = EXTRACT-MIN(Q)
                z.freq = x.freq + y.freq
                INSERT(Q, z)
                return EXTRACT-MIN(Q) // Root of tree
              </div>
              <div class="complexity-box">
                <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                <p>O(n lg n) due to priority queue operations</p>
              </div>
            </div>
            <div class="topic-card">
              <h5><i class="fas fa-check"></i> Optimality Proof</h5>
              <div class="theorem-box">
                <h4><i class="fas fa-bullseye"></i> Key Properties</h4>
                <ol>
                  <li>Characters with higher frequency get shorter codes</li>
                  <li>Two lowest-frequency characters have longest codes</li>
                  <li>Two lowest-frequency characters have codes differing only in last bit</li>
                </ol>
              </div>
            </div>
          </div>
        </div>
      </div>
      </section>
      <section id="lecture15" class="section">
        <h2 class="section-title">Graph Algorithms</h2>
        <div class="lecture-card">
          <div class="lecture-number">Lectures 15-16</div>
          <div class="subsection">
            <h3 class="subsection-title">1. Graph Representations</h3>
            <div class="algorithm-box">
              <h4><i class="fas fa-chart-bar"></i> Graph Definition</h4>
              <p>A graph G = (V, E) consists of:</p>
              <ul>
                <li><strong>V:</strong> A set of vertices (nodes)</li>
                <li><strong>E:</strong> A set of edges (connections between vertices)</li>
              </ul>
            </div>
            <div class="topics-grid">
              <div class="topic-card">
                <h5><i class="fas fa-clipboard"></i> Adjacency-List Representation</h5>
                <div class="algorithm-box">
                  <h4>Structure</h4>
                  <p>For each vertex u ? V, store a list of vertices adjacent to it.</p>
                  <div class="complexity-box">
                    <h5><i class="fas fa-chart-bar"></i> Properties</h5>
                    <ul>
                      <li><strong>Space:</strong> T(V + E)</li>
                      <li><strong>Good for:</strong> Sparse graphs (|E| << |V|�)</li>
                      <li><strong>Edge query:</strong> O(degree(u))</li>
                    </ul>
                  </div>
                </div>
              </div>
              <div class="topic-card">
                <h5><i class="fas fa-star"></i> Adjacency-Matrix Representation</h5>
                <div class="algorithm-box">
                  <h4>Structure</h4>
                  <p>|V| � |V| matrix A where A[i,j] = 1 if edge (i,j) ? E, else 0.</p>
                  <div class="complexity-box">
                    <h5><i class="fas fa-chart-bar"></i> Properties</h5>
                    <ul>
                      <li><strong>Space:</strong> T(V�)</li>
                      <li><strong>Good for:</strong> Dense graphs (|E| � |V|�)</li>
                      <li><strong>Edge query:</strong> O(1)</li>
                    </ul>
                  </div>
                </div>
              </div>
              <div class="topic-card">
                <h5><i class="fas fa-star"></i> Comparison</h5>
                <table class="comparison-table">
                  <thead>
                    <tr>
                      <th>Operation</th>
                      <th>Adj-List</th>
                      <th>Adj-Matrix</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Space</td>
                      <td>T(V + E)</td>
                      <td>T(V�)</td>
                    </tr>
                    <tr>
                      <td>Edge (u,v)?</td>
                      <td>O(deg(u))</td>
                      <td>O(1)</td>
                    </tr>
                    <tr>
                      <td>List neighbors</td>
                      <td>O(deg(u))</td>
                      <td>O(V)</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div class="subsection">
              <h3 class="subsection-title">2. Breadth-First Search (BFS)</h3>
              <div class="algorithm-box">
                <h4><i class="fas fa-wave"></i> BFS Strategy</h4>
                <p>Explores the graph layer by layer, starting from a given source vertex. It discovers all vertices
                  at distance k before discovering vertices at distance k+1.</p>
              </div>
              <div class="topics-grid">
                <div class="topic-card">
                  <h5><i class="fas fa-laptop-code"></i> BFS Algorithm</h5>
                  <div class="code-block">
                    BFS(G, s)
                    for each vertex u ? G.V - {s}
                    u.color = WHITE
                    u.d = 8
                    u.p = NIL
                    s.color = GRAY
                    s.d = 0
                    s.p = NIL
                    Q = �
                    ENQUEUE(Q, s)
                    while Q != �
                    u = DEQUEUE(Q)
                    for each v ? G.Adj[u]
                    if v.color == WHITE
                    v.color = GRAY
                    v.d = u.d + 1
                    v.p = u
                    ENQUEUE(Q, v)
                    u.color = BLACK
                  </div>
                </div>
                <div class="topic-card">
                  <h5><i class="fas fa-bullseye"></i> BFS Properties</h5>
                  <div class="theorem-box">
                    <h4><i class="fas fa-check"></i> Key Results</h4>
                    <ul>
                      <li>Computes shortest paths in <strong>unweighted</strong> graphs</li>
                      <li>Predecessor subgraph forms breadth-first tree</li>
                      <li>Distance d[v] = shortest path from source s</li>
                      <li>Vertices discovered in non-decreasing order of distance</li>
                    </ul>
                  </div>
                  <div class="complexity-box">
                    <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                    <p>T(V + E) on adjacency-list representation</p>
                  </div>
                </div>
                <div class="topic-card">
                  <h5><i class="fas fa-search"></i> Applications</h5>
                  <div class="algorithm-box">
                    <h4>Common Uses</h4>
                    <ul>
                      <li><strong>Shortest paths</strong> in unweighted graphs</li>
                      <li><strong>Connected components</strong></li>
                      <li><strong>Bipartite testing</strong></li>
                      <li><strong>Web crawling</strong></li>
                      <li><strong>Social network analysis</strong></li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
            <div class="subsection">
              <h3 class="subsection-title">3. Depth-First Search (DFS)</h3>
              <div class="algorithm-box">
                <h4><i class="fas fa-running"></i> DFS Strategy</h4>
                <p>Explores as far as possible along each branch before backtracking. Uses recursion (or stack) to
                  remember where to backtrack to.</p>
              </div>
              <div class="topics-grid">
                <div class="topic-card">
                  <h5><i class="fas fa-laptop-code"></i> DFS Algorithm</h5>
                  <div class="code-block">
                    DFS(G)
                    for each vertex u ? G.V
                    u.color = WHITE
                    u.p = NIL
                    time = 0
                    for each vertex u ? G.V
                    if u.color == WHITE
                    DFS-VISIT(G, u)
                    DFS-VISIT(G, u)
                    time = time + 1
                    u.d = time // Discovery time
                    u.color = GRAY
                    for each v ? G.Adj[u]
                    if v.color == WHITE
                    v.p = u
                    DFS-VISIT(G, v)
                    u.color = BLACK
                    time = time + 1
                    u.f = time // Finish time
                  </div>
                </div>
                <div class="topic-card">
                  <h5>? Timestamps</h5>
                  <div class="theorem-box">
                    <h4><i class="fas fa-star"></i> Discovery & Finish Times</h4>
                    <ul>
                      <li><strong>u.d:</strong> Discovery time (when first visited)</li>
                      <li><strong>u.f:</strong> Finish time (when fully processed)</li>
                      <li><strong>Property:</strong> u.d < u.f for all vertices u</li>
                    </ul>
                  </div>
                  <div class="complexity-box">
                    <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                    <p>T(V + E) on adjacency-list representation</p>
                  </div>
                </div>
                <div class="topic-card">
                  <h5><i class="fas fa-tags"></i> Edge Classification</h5>
                  <div class="algorithm-box">
                    <h4>Types of Edges</h4>
                    <ul>
                      <li><strong>Tree edges:</strong> Part of DFS tree</li>
                      <li><strong>Back edges:</strong> To ancestor in DFS tree</li>
                      <li><strong>Forward edges:</strong> To descendant (not tree edge)</li>
                      <li><strong>Cross edges:</strong> Between different subtrees</li>
                    </ul>
                    <div class="theorem-box">
                      <h4><i class="fas fa-search"></i> Cycle Detection</h4>
                      <p>A directed graph has a cycle ? DFS finds a back edge</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
      </section>
      <section id="lecture18" class="section">
        <h2 class="section-title">Advanced Graph Algorithms</h2>
        <div class="lecture-card">
          <div class="lecture-number">Lectures 18-19</div>
          <div class="subsection">
            <h3 class="subsection-title">1. Minimum Spanning Trees (MST)</h3>
            <div class="algorithm-box">
              <h4><i class="fas fa-star"></i> MST Definition</h4>
              <p>For a connected, undirected, weighted graph G = (V, E), a minimum spanning tree is a subgraph that:
              </p>
              <ul>
                <li>Is a <strong>tree</strong> (connected and acyclic)</li>
                <li><strong>Spans</strong> all vertices (includes every vertex)</li>
                <li>Has <strong>minimum total weight</strong> among all spanning trees</li>
              </ul>
            </div>
            <div class="theorem-box">
              <h4><i class="fas fa-bullseye"></i> Generic MST Algorithm</h4>
              <p>Maintains a set of edges A that is a subset of some MST. At each step, adds a "safe edge" to A.</p>
              <div class="algorithm-box">
                <h4><i class="fas fa-key"></i> Safe Edge Property</h4>
                <p>An edge (u,v) is safe for subset A if A ? {(u,v)} is also a subset of some MST.</p>
                <p><strong>Cut respect:</strong> A cut respects A if no edge in A crosses the cut.</p>
                <p><strong>Light edge:</strong> Minimum weight edge crossing a cut.</p>
              </div>
            </div>
            <div class="topics-grid">
              <div class="topic-card">
                <h5><i class="fas fa-building"></i> Kruskal's Algorithm</h5>
                <div class="algorithm-box">
                  <h4>Strategy</h4>
                  <p>Process edges in order of increasing weight. Add edge if it doesn't create a cycle.</p>
                </div>
                <div class="code-block">
                  MST-KRUSKAL(G, w)
                  A = �
                  for each vertex v ? G.V
                  MAKE-SET(v)
                  sort the edges of G.E into nondecreasing order by weight w
                  for each edge (u, v) ? G.E, taken in nondecreasing order by weight
                  if FIND-SET(u) != FIND-SET(v)
                  A = A ? {(u, v)}
                  UNION(u, v)
                  return A
                </div>
                <div class="complexity-box">
                  <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                  <p>O(E lg E) - dominated by sorting edges</p>
                </div>
              </div>
              <div class="topic-card">
                <h5><i class="fas fa-star"></i> Prim's Algorithm</h5>
                <div class="algorithm-box">
                  <h4>Strategy</h4>
                  <p>Start with arbitrary vertex. Grow MST by repeatedly adding minimum-weight edge connecting MST to
                    non-MST vertex.</p>
                </div>
                <div class="code-block">
                  MST-PRIM(G, w, r)
                  for each u ? G.V
                  u.key = 8
                  u.p = NIL
                  r.key = 0
                  Q = G.V
                  while Q != �
                  u = EXTRACT-MIN(Q)
                  for each v ? G.Adj[u]
                  if v ? Q and w(u, v) < v.key v.p=u v.key=w(u, v) </div>
                    <div class="complexity-box">
                      <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                      <ul>
                        <li><strong>Binary heap:</strong> O(E lg V)</li>
                        <li><strong>Fibonacci heap:</strong> O(E + V lg V)</li>
                      </ul>
                    </div>
                </div>
                <div class="topic-card">
                  <h5><i class="fas fa-star"></i> Kruskal vs Prim</h5>
                  <table class="comparison-table">
                    <thead>
                      <tr>
                        <th>Aspect</th>
                        <th>Kruskal</th>
                        <th>Prim</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><strong>Strategy</strong></td>
                        <td>Edge-based</td>
                        <td>Vertex-based</td>
                      </tr>
                      <tr>
                        <td><strong>Data Structure</strong></td>
                        <td>Disjoint sets</td>
                        <td>Priority queue</td>
                      </tr>
                      <tr>
                        <td><strong>Best for</strong></td>
                        <td>Sparse graphs</td>
                        <td>Dense graphs</td>
                      </tr>
                      <tr>
                        <td><strong>Time</strong></td>
                        <td>O(E lg E)</td>
                        <td>O(E lg V)</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="subsection">
                <h3 class="subsection-title">2. Single-Source Shortest Paths</h3>
                <div class="algorithm-box">
                  <h4><i class="fas fa-bullseye"></i> Problem Definition</h4>
                  <p>Given a weighted, directed graph G = (V, E) and a source vertex s, find the shortest path from s
                    to every other vertex in the graph.</p>
                  <div class="theorem-box">
                    <h4><i class="fas fa-key"></i> Key Concepts</h4>
                    <ul>
                      <li><strong>Shortest path weight:</strong> d(u, v) = minimum weight of path from u to v</li>
                      <li><strong>Relaxation:</strong> Process of improving shortest-path estimate</li>
                      <li><strong>Shortest-paths tree:</strong> Tree of shortest paths from source</li>
                    </ul>
                  </div>
                </div>
                <div class="topics-grid">
                  <div class="topic-card">
                    <h5><i class="fas fa-wrench"></i> Edge Relaxation</h5>
                    <div class="code-block">
                      INITIALIZE-SINGLE-SOURCE(G, s)
                      for each vertex v ? G.V
                      v.d = 8
                      v.p = NIL
                      s.d = 0
                      RELAX(u, v, w)
                      if v.d > u.d + w(u, v)
                      v.d = u.d + w(u, v)
                      v.p = u
                    </div>
                    <div class="algorithm-box">
                      <h4><i class="fas fa-lightbulb"></i> Relaxation Intuition</h4>
                      <p>If we can improve the shortest path to v by going through u, then update v's distance and
                        predecessor.</p>
                    </div>
                  </div>
                  <div class="topic-card">
                    <h5><i class="fas fa-bolt"></i> Dijkstra's Algorithm</h5>
                    <div class="algorithm-box">
                      <h4><i class="fas fa-bullseye"></i> Requirements</h4>
                      <p>Works only with <strong>non-negative edge weights</strong>.</p>
                    </div>
                    <div class="code-block">
                      DIJKSTRA(G, w, s)
                      INITIALIZE-SINGLE-SOURCE(G, s)
                      S = �
                      Q = G.V
                      while Q != �
                      u = EXTRACT-MIN(Q)
                      S = S ? {u}
                      for each vertex v ? G.Adj[u]
                      RELAX(u, v, w)
                    </div>
                    <div class="complexity-box">
                      <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                      <ul>
                        <li><strong>Array:</strong> T(V�)</li>
                        <li><strong>Binary heap:</strong> O(E lg V)</li>
                        <li><strong>Fibonacci heap:</strong> O(E + V lg V)</li>
                      </ul>
                    </div>
                  </div>
                  <div class="topic-card">
                    <h5><i class="fas fa-sync"></i> Bellman-Ford Algorithm</h5>
                    <div class="algorithm-box">
                      <h4><i class="fas fa-bullseye"></i> Features</h4>
                      <ul>
                        <li>Handles <strong>negative edge weights</strong></li>
                        <li>Detects <strong>negative-weight cycles</strong></li>
                        <li>Returns TRUE if no negative cycles</li>
                      </ul>
                    </div>
                    <div class="code-block">
                      BELLMAN-FORD(G, w, s)
                      INITIALIZE-SINGLE-SOURCE(G, s)
                      for i = 1 to |G.V| - 1
                      for each edge (u, v) ? G.E
                      RELAX(u, v, w)
                      for each edge (u, v) ? G.E
                      if v.d > u.d + w(u, v)
                      return FALSE
                      return TRUE
                    </div>
                    <div class="complexity-box">
                      <h5><i class="fas fa-stopwatch"></i> Time Complexity</h5>
                      <p>O(VE) - slower but more general than Dijkstra</p>
                    </div>
                  </div>
                </div>
                <div class="theorem-box">
                  <h4><i class="fas fa-chart-bar"></i> Algorithm Comparison</h4>
                  <table class="comparison-table">
                    <thead>
                      <tr>
                        <th>Algorithm</th>
                        <th>Edge Weights</th>
                        <th>Time Complexity</th>
                        <th>Detects Negative Cycles</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><strong>Dijkstra</strong></td>
                        <td>Non-negative</td>
                        <td>O(E + V lg V)</td>
                        <td>No</td>
                      </tr>
                      <tr>
                        <td><strong>Bellman-Ford</strong></td>
                        <td>Any (including negative)</td>
                        <td>O(VE)</td>
                        <td>Yes</td>
                      </tr>
                      <tr>
                        <td><strong>BFS (unweighted)</strong></td>
                        <td>Uniform (1 or unweighted)</td>
                        <td>O(V + E)</td>
                        <td>N/A</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
      </section>
    </div>
  </div>
  <!-- Add more sections as needed following the same pattern -->
  <div class="topic-section" id="lecture10">
    <div class="topic-header">
      <h2><i class="fas fa-star"></i> Dynamic Programming</h2>
      <div class="difficulty advanced">Advanced</div>
    </div>
    <div class="topic-content">
      <div class="subtopic">
        <h3><i class="fas fa-bullseye"></i> Dynamic Programming Approach</h3>
        <p>Solve optimization problems by breaking them down into subproblems and storing results to avoid
          recomputation.</p>
        <div class="code-example">
          <span class="comment">// Rod Cutting Problem</span>
          <span class="keyword">function</span> <span class="function">rodCutting</span>(prices, n) {
          <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="function">Array</span>(n +
          <span class="number">1</span>).<span class="function">fill</span>(<span class="number">0</span>);
          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i <= n;
            i++) { <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>;
            j <= i; j++) { dp[i]=<span class="function">Math.max</span>(dp[i], prices[j] + dp[i - j]);
              }
              }
              <span class="keyword">return</span> dp[n];
              }
              <span class="comment">// Time Complexity: O(n�)</span>
              <span class="comment">// Space Complexity: O(n)</span>
        </div>
      </div>
    </div>
  </div>
  <!-- Graph Algorithms -->
  <div class="topic-section" id="lecture15">
    <div class="topic-header">
      <h2><i class="fas fa-globe"></i> Graph Algorithms</h2>
      <div class="difficulty advanced">Advanced</div>
    </div>
    <div class="topic-content">
      <div class="subtopic">
        <h3><i class="fas fa-search"></i> Graph Search Algorithms</h3>
        <div class="code-example">
          <span class="comment">// Breadth-First Search (BFS)</span>
          <span class="keyword">function</span> <span class="function">BFS</span>(graph, start) {
          <span class="keyword">let</span> visited = <span class="keyword">new</span> <span
            class="function">Set</span>();
          <span class="keyword">let</span> queue = [start];
          <span class="keyword">let</span> result = [];
          <span class="keyword">while</span> (queue.<span class="property">length</span> > <span
            class="number">0</span>) {
          <span class="keyword">let</span> vertex = queue.<span class="function">shift</span>();
          <span class="keyword">if</span> (!visited.<span class="function">has</span>(vertex)) {
          visited.<span class="function">add</span>(vertex);
          result.<span class="function">push</span>(vertex);
          <span class="comment">// Add all neighbors to queue</span>
          <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span>
          graph[vertex]) {
          <span class="keyword">if</span> (!visited.<span class="function">has</span>(neighbor)) {
          queue.<span class="function">push</span>(neighbor);
          }
          }
          }
          }
          <span class="keyword">return</span> result;
          }
          <span class="comment">// Time Complexity: O(V + E)</span>
          <span class="comment">// Space Complexity: O(V)</span>
        </div>
      </div>
    </div>
  </div>
  </div>
  <script>
    function toggleTOC() {
      const tocContainer = document.getElementById('tocContainer');
      tocContainer.classList.toggle('active');
    }
    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    // Show/hide back to top button based on scroll position
    window.addEventListener('scroll', function () {
      const backToTop = document.getElementById('backToTop');
      if (window.pageYOffset > 300) {
        backToTop.classList.add('visible');
      } else {
        backToTop.classList.remove('visible');
      }
    });
    // Close TOC when clicking on a link
    document.addEventListener('DOMContentLoaded', function () {
      const tocLinks = document.querySelectorAll('.toc-list a');
      tocLinks.forEach(link => {
        link.addEventListener('click', function () {
          const tocContainer = document.getElementById('tocContainer');
          tocContainer.classList.remove('active');
        });
      });
    });
    // Close TOC when clicking outside
    document.addEventListener('click', function (event) {
      const tocContainer = document.getElementById('tocContainer');
      const tocToggle = document.querySelector('.toc-toggle');
      if (!tocContainer.contains(event.target) && !tocToggle.contains(event.target)) {
        tocContainer.classList.remove('active');
      }
    });
    // Smooth scrolling for anchor links
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
          target.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
        }
      });
    });
  </script>
  <!-- Shared JavaScript for dark mode and features -->
  <script src="../assets/js/main.js"></script>
</body>
</html>
</html>



